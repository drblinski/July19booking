<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Book Appointment | Get Plump</title>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: #f5f5f7;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }
    
    .booking-widget {
      width: 100%;
      max-width: 800px;
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      height: 80vh;
      min-height: 600px;
    }
    
    .chat-header {
      background: #ffffff;
      padding: 20px 30px;
      border-bottom: 1px solid #e5e5e7;
      text-align: center;
    }
    
    .chat-title {
      color: #1d1d1f;
      font-size: 1.3rem;
      font-weight: 600;
      margin-bottom: 5px;
    }
    
    .chat-subtitle {
      color: #86868b;
      font-size: 0.95rem;
    }
    
    .messages-container {
      flex: 1;
      padding: 20px 30px;
      overflow-y: auto;
      scroll-behavior: smooth;
      background: #fff;
    }
    
    .message {
      margin-bottom: 20px;
      display: flex;
      animation: slideIn 0.3s ease-out;
      max-width: 100%;
    }
    
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .message.system {
      justify-content: flex-start;
    }
    
    .message.user {
      justify-content: flex-end;
    }
    
    .message-bubble {
      max-width: 70%;
      padding: 12px 18px;
      border-radius: 18px;
      font-size: 1rem;
      line-height: 1.4;
      word-wrap: break-word;
    }
    
    .message.system .message-bubble {
      background: #e9e9eb;
      color: #1d1d1f;
      border-bottom-left-radius: 4px;
    }
    
    .message.user .message-bubble {
      background: #007AFF;
      color: #fff;
      border-bottom-right-radius: 4px;
    }
    
    .typing-indicator {
      display: flex;
      align-items: center;
      padding: 12px 18px;
      background: #e9e9eb;
      border-radius: 18px;
      border-bottom-left-radius: 4px;
      max-width: 80px;
    }
    
    .typing-dots {
      display: flex;
      gap: 4px;
    }
    
    .dot {
      width: 8px;
      height: 8px;
      background: #86868b;
      border-radius: 50%;
      animation: typing 1.4s infinite;
    }
    
    .dot:nth-child(2) { animation-delay: 0.2s; }
    .dot:nth-child(3) { animation-delay: 0.4s; }
    
    @keyframes typing {
      0%, 60%, 100% { transform: translateY(0); opacity: 0.5; }
      30% { transform: translateY(-6px); opacity: 1; }
    }
    
    /* Treatment Type Selection */
    .treatment-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-top: 15px;
    }
    
    .treatment-button {
      background: #fff;
      border: 2px solid #e5e5e7;
      color: #1d1d1f;
      padding: 20px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
      font-size: 1rem;
      font-weight: 500;
    }
    
    .treatment-button:hover {
      border-color: #007AFF;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 122, 255, 0.15);
    }
    .member-button {
  background: #1d1d1f !important;
  color: #fff !important;
  border-color: #1d1d1f !important;
}

.member-button:hover {
  background: #000 !important;
  border-color: #000 !important;
  color: #fff !important;
}

.member-button .treatment-desc {
  color: rgba(255, 255, 255, 0.8) !important;
}
    
    .treatment-title {
      font-weight: 600;
      margin-bottom: 8px;
      font-size: 1.1rem;
    }
    
    .treatment-desc {
      font-size: 0.9rem;
      color: #86868b;
      line-height: 1.3;
    }
    
    /* Improved Injector Display - Vertical List */
    .injector-container {
      margin-top: 15px;
    }
    
    .injector-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-height: 300px;
      overflow-y: auto;
      padding-right: 5px;
    }
    
    .injector-list::-webkit-scrollbar {
      width: 6px;
    }
    
    .injector-list::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 3px;
    }
    
    .injector-list::-webkit-scrollbar-thumb {
      background: #c1c1c1;
      border-radius: 3px;
    }
    
    .injector-list::-webkit-scrollbar-thumb:hover {
      background: #a8a8a8;
    }
    
    .injector-item {
      background: #fff;
      border: 2px solid #e5e5e7;
      border-radius: 25px;
      padding: 8px 16px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 12px;
      min-height: 50px;
    }
    
    .injector-item:hover {
      border-color: #007AFF;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0, 122, 255, 0.15);
    }
    
    .injector-item.first-available {
      background: #007AFF;
      color: #fff;
      border-color: #007AFF;
    }
    
    .injector-item.first-available:hover {
      background: #0056d6;
      border-color: #0056d6;
    }
    
    .injector-photo {
      width: 35px;
      height: 35px;
      border-radius: 50%;
      background: #e5e5e7;
      background-size: cover;
      background-position: center;
      flex-shrink: 0;
    }
    
    .injector-name {
      font-weight: 600;
      font-size: 0.95rem;
      flex: 1;
      text-align: left;
    }
    
    .injector-item.first-available .injector-name {
      color: #fff;
    }
    
    /* Calendar-style Time Selection */
    .availability-container {
      margin-top: 15px;
    }
    
    .calendar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding: 0 10px;
    }
    
    .calendar-nav {
      background: #f0f0f0;
      border: none;
      border-radius: 8px;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s ease;
    }
    
    .calendar-nav:hover {
      background: #e0e0e0;
    }
    
    .calendar-nav:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .calendar-title {
      font-weight: 600;
      font-size: 1rem;
      color: #1d1d1f;
    }
    
    .calendar-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 8px;
      margin-bottom: 15px;
    }
    
    .calendar-day-header {
      text-align: center;
      font-size: 0.8rem;
      color: #86868b;
      font-weight: 500;
      padding: 8px 4px;
    }
    
    .calendar-day {
      background: #f9f9f9;
      border: 1px solid #e5e5e7;
      border-radius: 8px;
      padding: 8px 4px;
      text-align: center;
      font-size: 0.85rem;
      min-height: 60px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }
    
    .calendar-day:hover {
      background: #f0f8ff;
      border-color: #007AFF;
    }
    
    .calendar-day.has-availability {
      background: #fff;
      border-color: #34c759;
    }
    
    .calendar-day.has-availability:hover {
      background: #f0fff4;
      border-color: #30a752;
    }
    
    .calendar-day.selected {
      background: #007AFF;
      color: #fff;
      border-color: #007AFF;
    }
    
    .calendar-day.disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    
    .calendar-day.disabled:hover {
      background: #f9f9f9;
      border-color: #e5e5e7;
    }
    
    .day-number {
      font-weight: 500;
      margin-bottom: 2px;
    }
    
    .day-availability {
      font-size: 0.7rem;
      color: #34c759;
      font-weight: 500;
    }
    
    .calendar-day.selected .day-availability {
      color: rgba(255, 255, 255, 0.8);
    }
    
    .time-slots {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 8px;
      max-height: 200px;
      overflow-y: auto;
      padding: 10px;
      background: #f9f9f9;
      border-radius: 8px;
    }
    
    .time-slot {
      background: #fff;
      border: 1px solid #e5e5e7;
      border-radius: 6px;
      padding: 8px;
      text-align: center;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .time-slot:hover {
      background: #f0f8ff;
      border-color: #007AFF;
    }
    
    /* Location Grid */
    .location-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 15px;
    }
    
    .location-button {
      background: #fff;
      border: 2px solid #e5e5e7;
      color: #1d1d1f;
      padding: 15px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
      font-size: 0.95rem;
      font-weight: 500;
    }
    
    .location-button:hover {
      border-color: #007AFF;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 122, 255, 0.15);
    }
    
    /* Service Grid */
    .service-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-top: 15px;
      max-height: 350px;
      overflow-y: auto;
    }
    
    .service-button {
      background: #fff;
      border: 2px solid #e5e5e7;
      color: #1d1d1f;
      padding: 18px 20px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: left;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .service-button:hover {
      border-color: #007AFF;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0, 122, 255, 0.15);
    }
    
    .service-info {
      flex: 1;
    }
    
    .service-name {
      font-weight: 600;
      margin-bottom: 4px;
      font-size: 1rem;
    }
    
    .service-duration {
      font-size: 0.85rem;
      color: #86868b;
    }
    
    .service-price {
      font-size: 1rem;
      font-weight: 600;
      color: #007AFF;
    }
    
    /* Form Container */
    .form-container {
      background: #f9f9f9;
      border-radius: 12px;
      padding: 25px;
      margin-top: 15px;
    }
    
    .form-input {
      width: 100%;
      background: #fff;
      border: 2px solid #e5e5e7;
      border-radius: 8px;
      padding: 12px 16px;
      color: #1d1d1f;
      font-size: 1rem;
      margin-bottom: 15px;
      transition: border-color 0.2s ease;
    }
    
    .form-input::placeholder {
      color: #86868b;
    }
    
    .form-input:focus {
      outline: none;
      border-color: #007AFF;
    }
    
    .form-input.error {
      border-color: #ff3b30;
    }
    
    .error-text {
      color: #ff3b30;
      font-size: 0.85rem;
      margin-top: -10px;
      margin-bottom: 10px;
    }
    
    .form-section-title {
      color: #1d1d1f;
      font-weight: 600;
      margin-bottom: 15px;
      margin-top: 20px;
      font-size: 1.1rem;
    }
    
    .form-section-title:first-child {
      margin-top: 0;
    }
    
    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
    }
    
    /* Buttons */
    .primary-button {
      background: #007AFF;
      color: #fff;
      border: none;
      padding: 15px 25px;
      border-radius: 25px;
      font-weight: 600;
      cursor: pointer;
      margin-top: 20px;
      width: 100%;
      font-size: 1rem;
      transition: all 0.2s ease;
    }
    
    .primary-button:hover {
      background: #0056d6;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3);
    }
    
    .primary-button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }
    
    .secondary-button {
      background: #34c759;
      color: #fff;
      border: none;
      padding: 12px 20px;
      border-radius: 20px;
      font-weight: 500;
      cursor: pointer;
      margin-top: 15px;
      width: 100%;
      font-size: 0.95rem;
      transition: all 0.2s ease;
    }
    
    .secondary-button:hover {
      background: #30a752;
      transform: translateY(-1px);
    }
    
    .restart-button {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #fff;
      border: 2px solid #e5e5e7;
      color: #1d1d1f;
      padding: 8px 16px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.2s ease;
      z-index: 1000;
      font-weight: 500;
    }
    
    .restart-button:hover {
      border-color: #007AFF;
      background: #f0f8ff;
    }
    
    .error-message {
      background: #ffebee;
      border: 2px solid #ffcdd2;
      color: #d32f2f;
      padding: 15px 18px;
      border-radius: 12px;
      margin-top: 15px;
      font-size: 0.95rem;
    }
    
    .success-message {
      background: #e8f5e8;
      border: 2px solid #c8e6c9;
      color: #2e7d32;
      padding: 15px 18px;
      border-radius: 12px;
      margin-top: 15px;
      font-size: 0.95rem;
    }
    
    .loading {
      opacity: 0.6;
      pointer-events: none;
    }
    
    /* Mobile Responsiveness */
    @media (max-width: 768px) {
      body {
        padding: 0;
        align-items: stretch;
      }
      
      .booking-widget {
        max-width: 100%;
        border-radius: 0;
        height: 100vh;
      }
      
      .messages-container {
        padding: 15px 20px;
      }
      
      .chat-header {
        padding: 15px 20px;
      }
      
      .treatment-grid {
        grid-template-columns: 1fr;
      }
      
      .form-row {
        grid-template-columns: 1fr;
      }
      
      .message-bubble {
        max-width: 85%;
      }
      
      .calendar-grid {
        grid-template-columns: repeat(7, 1fr);
        gap: 4px;
      }
      
      .calendar-day {
        min-height: 50px;
        padding: 4px 2px;
        font-size: 0.8rem;
      }
      
      .injector-list {
        gap: 8px;
        max-height: 250px;
      }
      
      .injector-item {
        padding: 6px 12px;
        min-height: 45px;
        gap: 10px;
      }
      
      .injector-photo {
        width: 30px;
        height: 30px;
      }
      
      .injector-name {
        font-size: 0.9rem;
      }
    }
    
    /* Injector Availability Styles */
    .location-legend {
      background: #f9f9f9;
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
    }
    
    .legend-title {
      font-weight: 600;
      margin-bottom: 10px;
      color: #1d1d1f;
      font-size: 0.95rem;
    }
    
    .legend-items {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 5px 10px;
      background: #fff;
      border-radius: 15px;
      border: 2px solid #e5e5e7;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.85rem;
    }
    
    .legend-item:hover {
      border-color: #007AFF;
      transform: translateY(-1px);
    }
    
    .legend-item.inactive {
      opacity: 0.5;
      background: #f5f5f5;
    }
    
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      flex-shrink: 0;
    }
    
    .injector-calendar-day {
      position: relative;
    }
    
    .calendar-slots {
      display: flex;
      flex-direction: column;
      gap: 2px;
      margin-top: 4px;
    }
    
    .slot-indicator {
      height: 3px;
      border-radius: 1px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .slot-indicator:hover {
      height: 5px;
      transform: translateY(-1px);
    }
    
    .slot-tooltip {
      position: absolute;
      background: #1d1d1f;
      color: #fff;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.75rem;
      white-space: nowrap;
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transform: translateY(-10px);
      transition: all 0.2s ease;
    }
    
    .slot-tooltip.visible {
      opacity: 1;
      transform: translateY(-5px);
    }
    
    .slot-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 4px solid transparent;
      border-top-color: #1d1d1f;
    }
    
    .injector-time-slots {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
      max-height: 250px;
      overflow-y: auto;
      padding: 10px;
      background: #f9f9f9;
      border-radius: 8px;
      margin-top: 15px;
    }
    
    .injector-time-slot {
      background: #fff;
      border: 2px solid #e5e5e7;
      border-radius: 8px;
      padding: 10px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }
    
    .injector-time-slot:hover {
      border-color: #007AFF;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0, 122, 255, 0.15);
    }
    
    .slot-time {
      font-weight: 600;
      font-size: 0.9rem;
      margin-bottom: 4px;
    }
    
    .slot-location {
      font-size: 0.75rem;
      color: #86868b;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    
    .slot-location-color {
      width: 8px;
      height: 8px;
      border-radius: 2px;
      flex-shrink: 0;
    }
  </style>
</head>
<body>
  <div class="booking-widget">
    <div class="chat-header">
      <div class="chat-title">Get Plump Booking</div>
      <div class="chat-subtitle">Book your appointment</div>
    </div>
    
    <div class="restart-button" onclick="restartChat()">Start Over</div>
    
    <div class="messages-container" id="messages"></div>
  </div>

  <script>
    // Debug logging
    console.log('Widget loading...');
    
    // Boulevard API Configuration - now using proxy route
    const BOULEVARD_CONFIG = {
      businessId: 'f6a06736-1132-4365-b79a-a69c648a746a',
      apiKey: '93ca3f15-6f0e-491d-840b-681a0fef80ed',
      apiUrl: '/api/blvd'  // Changed to use proxy route
    };
    
    const LOCATIONS_DATA = {
      'West Village': { 
        locationId: 'ffaaff3c-d5ba-408e-ba3b-455554b77116'
      },
      'SoHo': { 
        locationId: '89763e68-2454-429c-ae9c-c1b4d91e7b81'
      },
      'Tribeca': { 
        locationId: '43dfb866-a872-4f01-9491-6c6584e3c3e7'
      },
      'Williamsburg': { 
        locationId: '93566b17-c023-4fe1-9a84-462f143bd024'
      },
      'Hoboken': { 
        locationId: 'a885e859-21ef-43c7-8a63-bb242db98de2'
      },
      'Uptown': { 
        locationId: 'b146c47b-6de8-475a-8ebd-8a1d2b36546d'
      },
      'Miami': { 
        locationId: '1cbb848e-138b-4142-bc3d-b9f4ea9a42db'
      }
    };
    
    // Global state
    let conversationState = 'start';
    let treatmentType = null;
    let bookingFlow = null;
    let selectedLocation = null;
    let selectedLocationId = null;
    let selectedInjector = null;
    let selectedInjectorId = null;
    let selectedService = null;
    let selectedServiceId = null;
    let selectedTime = null;
    let cartId = null;
    let availableStaff = [];
    let availableServices = [];
    let availableTimes = [];
    let clientInfo = {};
    let currentCalendarDate = new Date();
    let calendarAvailability = {};
    let selectedDate = null;
    let injectorLocations = []; // For injector availability view
    let locationColors = {}; // Color mapping for locations
    let visibleLocations = new Set(); // Which locations are currently visible
    let injectorAvailabilityData = {}; // Availability data for injector view
    
    console.log('State initialized');
    
    // Utility functions
    function validateEmail(email) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return emailRegex.test(email);
    }
    
    function validatePhoneNumber(phone) {
      const digitsOnly = phone.replace(/\D/g, '');
      return digitsOnly.length >= 10 && digitsOnly.length <= 15;
    }
    
    // Boulevard API helper - Updated to use proxy route
    function makeBoulevardRequest(query, variables = {}) {
  console.log('🔥 Making Boulevard request:', { 
    query: query.substring(0, 100) + '...', 
    variables 
  });
  
  return fetch(BOULEVARD_CONFIG.apiUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    },
    body: JSON.stringify({
      query: query,
      variables: variables
    })
  })
  .then(response => {
    console.log('🔥 Boulevard response status:', response.status);
    
    // Handle different HTTP status codes
    if (response.status === 429) {
      throw new Error('Rate limit exceeded. Please wait a moment and try again.');
    }
    
    if (response.status === 500) {
      throw new Error('Server error. Please try again or contact support.');
    }
    
    if (response.status === 503) {
      throw new Error('Service temporarily unavailable. Please try again in a few minutes.');
    }
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    return response.json();
  })
  .then(data => {
    console.log('🔥 Boulevard response data:', data);
    
    if (data.errors && data.errors.length > 0) {
      console.error('🔥 Boulevard GraphQL errors:', data.errors);
      
      // Handle specific GraphQL error types
      const error = data.errors[0];
      if (error.message.includes('permission') || error.message.includes('unauthorized')) {
        throw new Error('Authentication error. Please refresh the page and try again.');
      }
      
      if (error.message.includes('validation')) {
        throw new Error('Invalid request. Please check your information and try again.');
      }
      
      throw new Error(`API Error: ${error.message}`);
    }
    
    return data.data;
  })
  .catch(error => {
    console.error('🔥 Boulevard request failed:', error);
    
    // Handle network errors
    if (error.name === 'TypeError' && error.message.includes('fetch')) {
      throw new Error('Network error. Please check your connection and try again.');
    }
    
    // Re-throw the error to be handled by the calling function
    throw error;
  });
}
    // Debug function to check what fields BookingCompleteInput expects
    function debugBookingCompleteSchema() {
      console.log('🔍 Debugging BookingCompleteInput schema...');
      
      const introspectionQuery = `
        query {
          __type(name: "BookingCompleteInput") {
            name
            inputFields {
              name
              type {
                name
                kind
                ofType {
                  name
                  kind
                }
              }
              description
            }
          }
        }
      `;
      
      return makeBoulevardRequest(introspectionQuery)
        .then(data => {
          console.log('📋 BookingCompleteInput schema:', data.__type);
          if (data.__type && data.__type.inputFields) {
            console.log('📋 Required fields:');
            data.__type.inputFields.forEach(field => {
              console.log(`  - ${field.name}: ${field.type.name || field.type.kind}${field.type.ofType ? ' of ' + field.type.ofType.name : ''}`);
            });
          }
          return data.__type;
        })
        .catch(error => {
          console.error('Could not fetch schema:', error);
          return null;
        });
    }
    
    // Debug cart status before booking
    function debugCartStatus() {
      console.log('🔍 Debugging cart status before booking...');
      
      const query = `
        query GetCart($cartId: ID!) {
          cart(id: $cartId) {
            id
            state
            expiresAt
            clientInformation {
              firstName
              lastName
              email
              phoneNumber
            }
            selectedItems {
              id
              item {
                name
              }
              selectedStaffVariant {
                staff {
                  firstName
                  lastName
                }
              }
            }
            bookableTime {
              id
              startTime
            }
            errors {
              field
              message
            }
          }
        }
      `;
      
      return makeBoulevardRequest(query, { cartId: cartId })
        .then(data => {
          console.log('🔍 Cart debug info:', data.cart);
          return data.cart;
        })
        .catch(error => {
          console.error('🔍 Cart debug failed:', error);
          return null;
        });
    }
    
    // FIXED: Complete booking using Boulevard's bookingComplete mutation
    function completeAPIBooking() {
      console.log('✅ Completing booking using bookingComplete mutation...');
      
      const mutation = `
        mutation BookingComplete($input: BookingCompleteInput!) {
          bookingComplete(input: $input) {
            booking {
              id
              state
              insertedAt
            }
            bookingAppointments {
              id
              startTime
              endTime
              state
              client {
                id
                firstName
                lastName
                email
                phoneNumber
              }
              location {
                id
                name
              }
              services {
                id
                name
              }
              staff {
                id
                firstName
                lastName
              }
            }
            bookingWarnings {
              field
              message
            }
          }
        }
      `;
      
      // Try different input structures based on common Boulevard patterns
      const inputVariations = [
        // Variation 1: Just cart ID
        { cartId: cartId },
        // Variation 2: ID field instead of cartId
        { id: cartId },
        // Variation 3: With payment information (null for no payment)
        { 
          cartId: cartId,
          paymentMethodId: null,
          gratuityAmount: 0
        },
        // Variation 4: Complete structure
        {
          cartId: cartId,
          paymentMethod: null,
          gratuity: { amount: 0 },
          discountCodes: []
        }
      ];
      
      // Try each variation until one works
      function tryBookingComplete(variationIndex = 0) {
        if (variationIndex >= inputVariations.length) {
          throw new Error('All booking completion variations failed');
        }
        
        const input = inputVariations[variationIndex];
        console.log(`✅ Trying booking completion variation ${variationIndex + 1}:`, input);
        
        return makeBoulevardRequest(mutation, { input: input })
          .then(data => {
            console.log('✅ Booking completed successfully:', data);
            
            const result = data.bookingComplete;
            
            // Check for warnings
            if (result.bookingWarnings && result.bookingWarnings.length > 0) {
              console.warn('⚠️ Booking warnings:', result.bookingWarnings);
            }
            
            // Verify appointments were created
            if (result.bookingAppointments && result.bookingAppointments.length > 0) {
              const appointment = result.bookingAppointments[0];
              console.log('✅ Appointment created with ID:', appointment.id);
              console.log('✅ Appointment details:', appointment);
              
              return {
                success: true,
                bookingId: result.booking.id,
                appointmentId: appointment.id,
                appointment: appointment,
                warnings: result.bookingWarnings
              };
            } else {
              throw new Error('No appointments were created in the booking');
            }
          })
          .catch(error => {
            console.error(`❌ Booking variation ${variationIndex + 1} failed:`, error);
            
            // If this variation failed, try the next one
            if (variationIndex < inputVariations.length - 1) {
              console.log(`⏭️ Trying next variation...`);
              return tryBookingComplete(variationIndex + 1);
            } else {
              throw error;
            }
          });
      }
      
      return tryBookingComplete();
    }
    
    // Initialize
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOM loaded, starting conversation');
      startConversation();
    });
    
    function startConversation() {
      console.log('Starting conversation');
      const container = document.getElementById('messages');
      container.innerHTML = '';
      conversationState = 'start';
      
      // Reset state
      treatmentType = null;
      bookingFlow = null;
      selectedLocation = null;
      selectedLocationId = null;
      selectedInjector = null;
      selectedInjectorId = null;
      selectedService = null;
      selectedServiceId = null;
      selectedTime = null;
      cartId = null;
      availableStaff = [];
      availableServices = [];
      availableTimes = [];
      clientInfo = {};
      currentCalendarDate = new Date();
      calendarAvailability = {};
      selectedDate = null;
      injectorLocations = [];
      locationColors = {};
      visibleLocations = new Set();
      injectorAvailabilityData = {};
      
      addMessage('system', "Hi! Welcome to Plump. I'll help you book your appointment.", function() {
        addMessage('system', "What type of client are you?", function() {
          showClientSelection();
        });
      });
    }
    
    function addMessage(type, text, callback) {
      const container = document.getElementById('messages');
      
      if (type === 'system') {
        showTyping(function() {
          const message = document.createElement('div');
          message.className = 'message ' + type;
          
          const bubble = document.createElement('div');
          bubble.className = 'message-bubble';
          bubble.innerHTML = text;
          
          message.appendChild(bubble);
          container.appendChild(message);
          scrollToBottom();
          
          if (callback) {
            setTimeout(callback, 500);
          }
        });
      } else {
        const message = document.createElement('div');
        message.className = 'message ' + type;
        
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble';
        bubble.textContent = text;
        
        message.appendChild(bubble);
        container.appendChild(message);
        scrollToBottom();
        
        if (callback) {
          setTimeout(callback, 300);
        }
      }
    }
    
    function showTyping(callback) {
      const container = document.getElementById('messages');
      const typingMessage = document.createElement('div');
      typingMessage.className = 'message system';
      typingMessage.id = 'typing-indicator';
      
      const typingIndicator = document.createElement('div');
      typingIndicator.className = 'typing-indicator';
      
      const typingDots = document.createElement('div');
      typingDots.className = 'typing-dots';
      
      for (let i = 0; i < 3; i++) {
        const dot = document.createElement('div');
        dot.className = 'dot';
        typingDots.appendChild(dot);
      }
      
      typingIndicator.appendChild(typingDots);
      typingMessage.appendChild(typingIndicator);
      container.appendChild(typingMessage);
      scrollToBottom();
      
      setTimeout(function() {
        const indicator = document.getElementById('typing-indicator');
        if (indicator) {
          indicator.remove();
        }
        callback();
      }, 1200);
    }
    
    function showClientSelection() {
      console.log('Showing client type selection');
      const container = document.getElementById('messages');
      const clientMessage = document.createElement('div');
      clientMessage.className = 'message system';
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      
      const grid = document.createElement('div');
      grid.className = 'treatment-grid';
      grid.style.gridTemplateColumns = '1fr'; // Stack vertically
      
      // New Client
      const newButton = document.createElement('button');
      newButton.className = 'treatment-button';
      newButton.onclick = () => selectClientType('new');
      
      const newTitle = document.createElement('div');
      newTitle.className = 'treatment-title';
      newTitle.textContent = 'New Client';
      
      const newDesc = document.createElement('div');
      newDesc.className = 'treatment-desc';
      newDesc.textContent = 'First time at Get Plump';
      
      newButton.appendChild(newTitle);
      newButton.appendChild(newDesc);
      
      // Returning Client
      const returningButton = document.createElement('button');
      returningButton.className = 'treatment-button';
      returningButton.onclick = () => selectClientType('returning');
      
      const returningTitle = document.createElement('div');
      returningTitle.className = 'treatment-title';
      returningTitle.textContent = 'Returning Client';
      
      const returningDesc = document.createElement('div');
      returningDesc.className = 'treatment-desc';
      returningDesc.textContent = 'I\'ve been here before';
      
      returningButton.appendChild(returningTitle);
      returningButton.appendChild(returningDesc);
      
      // Member
      const memberButton = document.createElement('button');
      memberButton.className = 'treatment-button member-button';
      memberButton.onclick = () => selectClientType('member');
      
      const memberTitle = document.createElement('div');
      memberTitle.className = 'treatment-title';
      memberTitle.textContent = 'Member';
      
      const memberDesc = document.createElement('div');
      memberDesc.className = 'treatment-desc';
      memberDesc.textContent = 'I\'m a Get Plump member';
      
      memberButton.appendChild(memberTitle);
      memberButton.appendChild(memberDesc);
      
      grid.appendChild(newButton);
      grid.appendChild(returningButton);
      grid.appendChild(memberButton);
      
      bubble.appendChild(grid);
      clientMessage.appendChild(bubble);
      container.appendChild(clientMessage);
      scrollToBottom();
    }
    
    function selectClientType(type) {
      clientType = type;
      const typeNames = {
        'new': 'New Client',
        'returning': 'Returning Client',
        'member': 'Member'
      };
      addMessage('user', typeNames[type]);
      
      let message = 'Great choice!';
      if (type === 'new') {
        message = 'Welcome! As a new client, you\'ll get special pricing.';
      } else if (type === 'member') {
        message = 'VIP access activated!';
        document.querySelector('.booking-widget').classList.add('dark-mode');
      }
      
      addMessage('system', message + ' What type of treatment are you interested in?', function() {
        showTreatmentTypeSelection();
      });
    }
    
    function showTreatmentTypeSelection() {
      console.log('Showing treatment type selection');
      const container = document.getElementById('messages');
      const treatmentMessage = document.createElement('div');
      treatmentMessage.className = 'message system';
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      
      const grid = document.createElement('div');
      grid.className = 'treatment-grid';
      grid.style.gridTemplateColumns = '1fr'; // Stack vertically for 3 options
      
      // Injectable button
      const injectableButton = document.createElement('button');
      injectableButton.className = 'treatment-button';
      injectableButton.onclick = () => selectTreatmentType('injectable');
      
      const injectableTitle = document.createElement('div');
      injectableTitle.className = 'treatment-title';
      injectableTitle.textContent = 'Injectable Treatments';
      
      const injectableDesc = document.createElement('div');
      injectableDesc.className = 'treatment-desc';
      injectableDesc.textContent = 'Botox, fillers, and other injectable services';
      
      injectableButton.appendChild(injectableTitle);
      injectableButton.appendChild(injectableDesc);
      
      // Skin treatments button
      const skinButton = document.createElement('button');
      skinButton.className = 'treatment-button';
      skinButton.onclick = () => selectTreatmentType('skin');
      
      const skinTitle = document.createElement('div');
      skinTitle.className = 'treatment-title';
      skinTitle.textContent = 'Skin Treatments';
      
      const skinDesc = document.createElement('div');
      skinDesc.className = 'treatment-desc';
      skinDesc.textContent = 'Laser, microneedling, and skincare services';
      
      skinButton.appendChild(skinTitle);
      skinButton.appendChild(skinDesc);
      
      // Injector availability button
      const injectorAvailButton = document.createElement('button');
      injectorAvailButton.className = 'treatment-button';
      injectorAvailButton.onclick = () => selectTreatmentType('injector-availability');
      
      const injectorAvailTitle = document.createElement('div');
      injectorAvailTitle.className = 'treatment-title';
      injectorAvailTitle.textContent = 'See a Specific Injector\'s Availability';
      
      const injectorAvailDesc = document.createElement('div');
      injectorAvailDesc.className = 'treatment-desc';
      injectorAvailDesc.textContent = 'View open slots for your preferred injector across all locations';
      
      injectorAvailButton.appendChild(injectorAvailTitle);
      injectorAvailButton.appendChild(injectorAvailDesc);
      
      grid.appendChild(injectableButton);
      grid.appendChild(skinButton);
      grid.appendChild(injectorAvailButton);
      
      bubble.appendChild(grid);
      treatmentMessage.appendChild(bubble);
      container.appendChild(treatmentMessage);
      scrollToBottom();
    }
    
    function selectTreatmentType(type) {
  treatmentType = type;
  
  if (type === 'injectable') {
    addMessage('user', 'Injectable Treatments');
    addMessage('system', 'Great! First, what type of client are you?', function() {
      showClientSelection();
    });
  } else if (type === 'skin') {
    addMessage('user', 'Skin Treatments');
    addMessage('system', 'Perfect! First, what type of client are you?', function() {
      showClientSelection();
    });
  } else if (type === 'injector-availability') {
    addMessage('user', 'See a Specific Injector\'s Availability');
    addMessage('system', 'Perfect! Let me load our team of injectors and their availability...', function() {
      loadInjectorsForAvailability();
    });
  }
}
    
    function showInjectableBookingFlow() {
      const container = document.getElementById('messages');
      const flowMessage = document.createElement('div');
      flowMessage.className = 'message system';
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      
      const grid = document.createElement('div');
      grid.className = 'treatment-grid';
      
      // Book by injector
      const injectorButton = document.createElement('button');
      injectorButton.className = 'treatment-button';
      injectorButton.onclick = () => selectBookingFlow('by-injector');
      
      const injectorTitle = document.createElement('div');
      injectorTitle.className = 'treatment-title';
      injectorTitle.textContent = 'Book by Injector';
      
      const injectorDesc = document.createElement('div');
      injectorDesc.className = 'treatment-desc';
      injectorDesc.textContent = 'Choose your preferred injector first';
      
      injectorButton.appendChild(injectorTitle);
      injectorButton.appendChild(injectorDesc);
      
      // Book by location
      const locationButton = document.createElement('button');
      locationButton.className = 'treatment-button';
      locationButton.onclick = () => selectBookingFlow('by-location');
      
      const locationTitle = document.createElement('div');
      locationTitle.className = 'treatment-title';
      locationTitle.textContent = 'Book by Location';
      
      const locationDesc = document.createElement('div');
      locationDesc.className = 'treatment-desc';
      locationDesc.textContent = 'Choose your preferred location first';
      
      locationButton.appendChild(locationTitle);
      locationButton.appendChild(locationDesc);
      
      grid.appendChild(injectorButton);
      grid.appendChild(locationButton);
      
      bubble.appendChild(grid);
      flowMessage.appendChild(bubble);
      container.appendChild(flowMessage);
      scrollToBottom();
    }
    
    function selectBookingFlow(flow) {
      bookingFlow = flow;
      addMessage('user', flow === 'by-injector' ? 'Book by Injector' : 'Book by Location');
      
      if (flow === 'by-injector') {
        addMessage('system', 'Let me show you our available injectors...', function() {
          loadInjectors();
        });
      } else {
        addMessage('system', 'Please select your preferred location:', function() {
          showLocationSelection();
        });
      }
    }
    
    function loadInjectors() {
      console.log('🔍 Loading injectors from Boulevard API...');
      
      // Show loading state
      addMessage('system', 'Loading our team of injectors...');
      
      // Check all locations to get complete staff list
      const locationEntries = Object.entries(LOCATIONS_DATA);
      
      console.log('🔍 Checking locations:', locationEntries.map(([name, data]) => name));
      
      // We'll aggregate staff from all locations and track which locations they work at
      const allStaffPromises = locationEntries.map(([locationName, locationData]) => {
        const locationId = locationData.locationId.indexOf('urn:blvd:Location:') === 0 ? 
          locationData.locationId : 'urn:blvd:Location:' + locationData.locationId;
        
        console.log('🔍 Creating cart for location:', locationName, locationId);
        
        const query = `
          mutation CreateTempCart($locationId: ID!) {
            createCart(input: { locationId: $locationId }) {
              cart {
                id
                availableCategories {
                  name
                  availableItems {
                    id
                    name
                    ... on CartAvailableBookableItem {
                      staffVariants {
                        id
                        staff {
                          id
                          firstName
                          lastName
                          nickname
                          avatar
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        `;
        
        return makeBoulevardRequest(query, { locationId: locationId })
          .then(data => {
            console.log('🔍 Response from location:', locationName, data);
            return {
              locationName: locationName,
              locationId: locationId,
              cart: data.createCart.cart
            };
          })
          .catch(error => {
            console.error('🔍 Failed to load from location:', locationName, error);
            return {
              locationName: locationName,
              locationId: locationId,
              cart: null,
              error: error.message
            };
          });
      });
      
      Promise.all(allStaffPromises)
        .then(responses => {
          console.log('🔍 All cart responses received:', responses);
          
          const staffMap = new Map();
          let totalItemsChecked = 0;
          let totalStaffVariantsFound = 0;
          let locationsWithErrors = [];
          
          responses.forEach(response => {
            if (!response || !response.cart) {
              if (response && response.error) {
                locationsWithErrors.push(`${response.locationName}: ${response.error}`);
              }
              return;
            }
            
            const { locationName, cart } = response;
            console.log(`🔍 Processing cart for ${locationName}:`, cart);
            
            if (cart.availableCategories) {
              cart.availableCategories.forEach(category => {
                console.log(`🔍 Processing category: ${category.name}`);
                if (category.availableItems) {
                  category.availableItems.forEach(item => {
                    totalItemsChecked++;
                    console.log(`🔍 Processing item: ${item.name}`, item.staffVariants);
                    
                    if (item.staffVariants && item.staffVariants.length > 0) {
                      totalStaffVariantsFound += item.staffVariants.length;
                      item.staffVariants.forEach(variant => {
                        if (variant.staff) {
                          console.log(`🔍 Processing staff variant:`, variant.staff);
                          if (!staffMap.has(variant.staff.id)) {
                            staffMap.set(variant.staff.id, {
                              id: variant.staff.id,
                              firstName: variant.staff.firstName,
                              lastName: variant.staff.lastName,
                              nickname: variant.staff.nickname,
                              avatar: variant.staff.avatar ? { url: variant.staff.avatar } : null,
                              role: { name: 'Provider' },
                              locations: [locationName] // Track locations
                            });
                          } else {
                            // Add this location to the staff member's locations
                            const staff = staffMap.get(variant.staff.id);
                            if (!staff.locations.includes(locationName)) {
                              staff.locations.push(locationName);
                            }
                          }
                        }
                      });
                    }
                  });
                }
              });
            }
          });
          
          if (locationsWithErrors.length > 0) {
            console.log('🔍 Locations with errors:', locationsWithErrors);
          }
          
          console.log(`🔍 Summary: ${totalItemsChecked} items checked across all locations, ${totalStaffVariantsFound} staff variants found`);
          
          const staffList = Array.from(staffMap.values());
          console.log('🔍 Final staff list with locations:', staffList);
          
          if (staffList.length > 0) {
            console.log('✅ Successfully loaded staff from Boulevard:', staffList);
            console.log('✅ Staff and their locations:', staffList.map(s => 
              `${s.firstName} ${s.lastName}: ${s.locations.join(', ')}`
            ));
            availableStaff = staffList;
            
            // Force refresh the injector display
            console.log('🔄 Refreshing injector display...');
            showInjectors();
          } else {
            console.log('❌ No staff found in Boulevard API, using enhanced mock data');
            loadEnhancedMockStaff();
          }
        })
        .catch(error => {
          console.error('❌ Failed to load staff from all locations:', error);
          console.log('❌ Falling back to enhanced mock staff data');
          loadEnhancedMockStaff();
        });
    }
    
    function loadEnhancedMockStaff() {
      console.log('Using enhanced mock staff data with more comprehensive team');
      
      const mockStaff = [
        {
          id: 'staff1',
          firstName: 'Sarah',
          lastName: 'Johnson',
          role: { name: 'Senior Injector' },
          avatar: null,
          locations: ['West Village', 'SoHo']
        },
        {
          id: 'staff2',
          firstName: 'Michael',
          lastName: 'Chen',
          role: { name: 'Lead Aesthetician' },
          avatar: null,
          locations: ['Tribeca', 'Williamsburg']
        },
        {
          id: 'staff3',
          firstName: 'Emily',
          lastName: 'Rodriguez',
          role: { name: 'Injector' },
          avatar: null,
          locations: ['Hoboken', 'Uptown']
        },
        {
          id: 'staff4',
          firstName: 'David',
          lastName: 'Thompson',
          role: { name: 'Medical Director' },
          avatar: null,
          locations: ['Miami', 'West Village']
        },
        {
          id: 'staff5',
          firstName: 'Jessica',
          lastName: 'Martinez',
          role: { name: 'Senior Injector' },
          avatar: null,
          locations: ['SoHo', 'Tribeca']
        },
        {
          id: 'staff6',
          firstName: 'Alex',
          lastName: 'Kim',
          role: { name: 'Aesthetic Nurse' },
          avatar: null,
          locations: ['Williamsburg', 'Hoboken']
        },
        {
          id: 'staff7',
          firstName: 'Rachel',
          lastName: 'Davis',
          role: { name: 'Injector' },
          avatar: null,
          locations: ['Uptown', 'Miami']
        },
        {
          id: 'staff8',
          firstName: 'Marcus',
          lastName: 'Wilson',
          role: { name: 'Lead Injector' },
          avatar: null,
          locations: ['West Village', 'Tribeca', 'SoHo']
        },
        {
          id: 'staff9',
          firstName: 'Lisa',
          lastName: 'Brown',
          role: { name: 'Aesthetic Specialist' },
          avatar: null,
          locations: ['Williamsburg', 'Uptown']
        },
        {
          id: 'staff10',
          firstName: 'James',
          lastName: 'Garcia',
          role: { name: 'Senior Aesthetician' },
          avatar: null,
          locations: ['Hoboken', 'Miami']
        }
      ];
      
      availableStaff = mockStaff;
      console.log('✅ Enhanced mock staff loaded:', mockStaff.length, 'team members');
      showInjectors();
    }
    
    function showInjectors() {
      console.log('🎨 Showing injectors with pill layout');
      
      const container = document.getElementById('messages');
      const injectorsMessage = document.createElement('div');
      injectorsMessage.className = 'message system';
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      
      const injectorContainer = document.createElement('div');
      injectorContainer.className = 'injector-container';
      
      const injectorList = document.createElement('div');
      injectorList.className = 'injector-list';
      
      // First Available option if in by-location flow or similar
      if (bookingFlow === 'by-location') {
        const firstAvailableItem = document.createElement('div');
        firstAvailableItem.className = 'injector-item first-available';
        firstAvailableItem.onclick = () => selectInjector('first-available', 'First Available');
        
        const firstAvailablePhoto = document.createElement('div');
        firstAvailablePhoto.className = 'injector-photo';
        
        const firstAvailableName = document.createElement('div');
        firstAvailableName.className = 'injector-name';
        firstAvailableName.textContent = 'First Available';
        
        firstAvailableItem.appendChild(firstAvailablePhoto);
        firstAvailableItem.appendChild(firstAvailableName);
        
        injectorList.appendChild(firstAvailableItem);
      }
      
      // Individual injectors
      availableStaff.forEach((staff, index) => {
        console.log(`🎨 Creating pill for staff ${index + 1}:`, staff);
        
        const item = document.createElement('div');
        item.className = 'injector-item';
        item.onclick = () => selectInjector(staff.id, staff.firstName + ' ' + staff.lastName);
        
        const photo = document.createElement('div');
        photo.className = 'injector-photo';
        if (staff.avatar && staff.avatar.url) {
          photo.style.backgroundImage = `url(${staff.avatar.url})`;
        }
        
        const name = document.createElement('div');
        name.className = 'injector-name';
        name.textContent = staff.firstName + ' ' + staff.lastName;
        
        item.appendChild(photo);
        item.appendChild(name);
        
        injectorList.appendChild(item);
      });
      
      injectorContainer.appendChild(injectorList);
      bubble.appendChild(injectorContainer);
      
      const smsButton = document.createElement('button');
      smsButton.className = 'secondary-button';
      smsButton.textContent = "Don't see your preferred injector? Contact us";
      smsButton.onclick = () => openSMS('injector-inquiry');
      bubble.appendChild(smsButton);
      
      injectorsMessage.appendChild(bubble);
      container.appendChild(injectorsMessage);
      scrollToBottom();
      
      console.log('🎨 Injector pill display complete');
    }
    
    // NEW: Load injectors specifically for availability view
    function loadInjectorsForAvailability() {
      console.log('🔍 Loading injectors for availability view...');
      
      // Show loading state
      const container = document.getElementById('messages');
      const loadingMessage = document.createElement('div');
      loadingMessage.className = 'message system';
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      bubble.textContent = 'Loading our team of injectors...';
      
      loadingMessage.appendChild(bubble);
      container.appendChild(loadingMessage);
      scrollToBottom();
      
      // Get all locations and their staff
      const locationEntries = Object.entries(LOCATIONS_DATA);
      console.log('🔍 Loading staff from all locations for availability view');
      
      const allStaffPromises = locationEntries.map(([locationName, locationData]) => {
        const locationId = locationData.locationId.indexOf('urn:blvd:Location:') === 0 ? 
          locationData.locationId : 'urn:blvd:Location:' + locationData.locationId;
        
        const query = `
          mutation CreateTempCart($locationId: ID!) {
            createCart(input: { locationId: $locationId }) {
              cart {
                id
                availableCategories {
                  name
                  availableItems {
                    id
                    name
                    ... on CartAvailableBookableItem {
                      staffVariants {
                        id
                        staff {
                          id
                          firstName
                          lastName
                          nickname
                          avatar
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        `;
        
        return makeBoulevardRequest(query, { locationId: locationId })
          .then(data => ({
            locationName: locationName,
            locationId: locationId,
            cart: data.createCart.cart
          }))
          .catch(error => {
            console.error('🔍 Failed to load from location:', locationName, error);
            return { locationName: locationName, locationId: locationId, cart: null };
          });
      });
      
      Promise.all(allStaffPromises)
        .then(responses => {
          const staffMap = new Map();
          
          responses.forEach(response => {
            if (!response.cart) return;
            
            const { locationName, cart } = response;
            
            if (cart.availableCategories) {
              cart.availableCategories.forEach(category => {
                if (category.availableItems) {
                  category.availableItems.forEach(item => {
                    if (item.staffVariants && item.staffVariants.length > 0) {
                      item.staffVariants.forEach(variant => {
                        if (variant.staff) {
                          if (!staffMap.has(variant.staff.id)) {
                            staffMap.set(variant.staff.id, {
                              id: variant.staff.id,
                              firstName: variant.staff.firstName,
                              lastName: variant.staff.lastName,
                              nickname: variant.staff.nickname,
                              avatar: variant.staff.avatar ? { url: variant.staff.avatar } : null,
                              locations: [locationName]
                            });
                          } else {
                            const staff = staffMap.get(variant.staff.id);
                            if (!staff.locations.includes(locationName)) {
                              staff.locations.push(locationName);
                            }
                          }
                        }
                      });
                    }
                  });
                }
              });
            }
          });
          
          const staffList = Array.from(staffMap.values());
          
          if (staffList.length > 0) {
            console.log('✅ Successfully loaded staff for availability view:', staffList);
            availableStaff = staffList;
            assignLocationColors(staffList);
            showInjectorsForAvailability();
          } else {
            console.log('❌ No staff found, using mock data');
            loadMockStaffForAvailability();
          }
        })
        .catch(error => {
          console.error('❌ Failed to load staff:', error);
          loadMockStaffForAvailability();
        });
    }
    
    function loadMockStaffForAvailability() {
      const mockStaff = [
        {
          id: 'staff1',
          firstName: 'Sarah',
          lastName: 'Johnson',
          avatar: null,
          locations: ['West Village', 'SoHo']
        },
        {
          id: 'staff2',
          firstName: 'Michael',
          lastName: 'Chen',
          avatar: null,
          locations: ['Tribeca', 'Williamsburg']
        },
        {
          id: 'staff3',
          firstName: 'Emily',
          lastName: 'Rodriguez',
          avatar: null,
          locations: ['Hoboken', 'Uptown']
        },
        {
          id: 'staff4',
          firstName: 'David',
          lastName: 'Thompson',
          avatar: null,
          locations: ['Miami', 'West Village']
        },
        {
          id: 'staff5',
          firstName: 'Jessica',
          lastName: 'Martinez',
          avatar: null,
          locations: ['SoHo', 'Tribeca']
        }
      ];
      
      availableStaff = mockStaff;
      assignLocationColors(mockStaff);
      showInjectorsForAvailability();
    }
    
    function assignLocationColors(staffList) {
      const colors = ['#007AFF', '#34C759', '#FF9500', '#FF3B30', '#5856D6', '#AF52DE', '#FF2D92', '#64D2FF'];
      const allLocations = new Set();
      
      staffList.forEach(staff => {
        staff.locations.forEach(location => allLocations.add(location));
      });
      
      const locationArray = Array.from(allLocations);
      locationColors = {};
      
      locationArray.forEach((location, index) => {
        locationColors[location] = colors[index % colors.length];
      });
      
      console.log('🎨 Assigned location colors:', locationColors);
    }
    
    function showInjectorsForAvailability() {
      console.log('🎨 Showing injectors for availability view');
      
      // Remove loading message
      const messages = document.querySelectorAll('.message');
      const lastMessage = messages[messages.length - 1];
      if (lastMessage && lastMessage.textContent.includes('Loading our team')) {
        lastMessage.remove();
      }
      
      const container = document.getElementById('messages');
      const injectorsMessage = document.createElement('div');
      injectorsMessage.className = 'message system';
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      bubble.innerHTML = 'Select an injector to view their availability across all locations:';
      
      const injectorContainer = document.createElement('div');
      injectorContainer.className = 'injector-container';
      
      const injectorList = document.createElement('div');
      injectorList.className = 'injector-list';
      
      // Show individual injectors
      availableStaff.forEach((staff, index) => {
        const item = document.createElement('div');
        item.className = 'injector-item';
        item.onclick = () => selectInjectorForAvailability(staff);
        
        const photo = document.createElement('div');
        photo.className = 'injector-photo';
        if (staff.avatar && staff.avatar.url) {
          photo.style.backgroundImage = `url(${staff.avatar.url})`;
        }
        
        const name = document.createElement('div');
        name.className = 'injector-name';
        name.textContent = `${staff.firstName} ${staff.lastName}`;
        
        // Add location info
        const locations = document.createElement('div');
        locations.style.fontSize = '0.8rem';
        locations.style.color = '#86868b';
        locations.style.marginTop = '4px';
        locations.textContent = staff.locations.join(', ');
        
        const info = document.createElement('div');
        info.style.flex = '1';
        info.appendChild(name);
        info.appendChild(locations);
        
        item.appendChild(photo);
        item.appendChild(info);
        
        injectorList.appendChild(item);
      });
      
      injectorContainer.appendChild(injectorList);
      bubble.appendChild(injectorContainer);
      
      injectorsMessage.appendChild(bubble);
      container.appendChild(injectorsMessage);
      scrollToBottom();
    }
    
    function selectInjectorForAvailability(staff) {
      selectedInjector = `${staff.firstName} ${staff.lastName}`;
      selectedInjectorId = staff.id;
      injectorLocations = staff.locations;
      
      // Initialize all locations as visible
      visibleLocations = new Set(staff.locations);
      
      addMessage('user', selectedInjector);
      addMessage('system', `Perfect! Loading ${selectedInjector}'s availability across all locations...`, function() {
        loadInjectorAvailabilityAcrossLocations();
      });
    }
    
    function loadInjectorAvailabilityAcrossLocations() {
      console.log('🔍 Loading availability for injector across all locations');
      
      const promises = injectorLocations.map(locationName => {
        return loadInjectorAvailabilityForLocation(locationName);
      });
      
      Promise.all(promises)
        .then(() => {
          console.log('✅ Loaded availability for all locations');
          showInjectorAvailabilityCalendar();
        })
        .catch(error => {
          console.error('❌ Failed to load availability:', error);
          showErrorMessage('Unable to load availability. Please try again or contact us.');
        });
    }
    
    function loadInjectorAvailabilityForLocation(locationName) {
      const locationData = LOCATIONS_DATA[locationName];
      if (!locationData) {
        console.error('Location not found:', locationName);
        return Promise.resolve();
      }
      
      const locationId = locationData.locationId.indexOf('urn:blvd:Location:') === 0 ? 
        locationData.locationId : 'urn:blvd:Location:' + locationData.locationId;
      
      console.log(`🔍 Loading availability for ${locationName}`);
      
      // Create a temporary cart for this location
      const createCartQuery = `
        mutation CreateTempCart($locationId: ID!) {
          createCart(input: { locationId: $locationId }) {
            cart {
              id
              availableCategories {
                availableItems {
                  id
                  name
                  ... on CartAvailableBookableItem {
                    staffVariants {
                      id
                      staff {
                        id
                        firstName
                        lastName
                      }
                    }
                  }
                }
              }
            }
          }
        }
      `;
      
      return makeBoulevardRequest(createCartQuery, { locationId: locationId })
        .then(data => {
          const cart = data.createCart.cart;
          
          // Find a service that this injector can perform
          let selectedServiceId = null;
          let selectedStaffVariantId = null;
          
          for (const category of cart.availableCategories) {
            for (const item of category.availableItems) {
              if (item.staffVariants) {
                const staffVariant = item.staffVariants.find(variant => 
                  variant.staff && variant.staff.id === selectedInjectorId
                );
                if (staffVariant) {
                  selectedServiceId = item.id;
                  selectedStaffVariantId = staffVariant.id;
                  break;
                }
              }
            }
            if (selectedServiceId) break;
          }
          
          if (!selectedServiceId) {
            console.log(`No services found for injector at ${locationName}`);
            return;
          }
          
          // Add service to cart
          const addServiceQuery = `
            mutation AddCartItem($cartId: ID!, $itemId: ID!, $itemStaffVariantId: ID!) {
              addCartSelectedBookableItem(input: {
                id: $cartId,
                itemId: $itemId,
                itemStaffVariantId: $itemStaffVariantId
              }) {
                cart {
                  id
                }
              }
            }
          `;
          
          return makeBoulevardRequest(addServiceQuery, {
            cartId: cart.id,
            itemId: selectedServiceId,
            itemStaffVariantId: selectedStaffVariantId
          }).then(() => {
            // Load availability for the next 30 days
            const promises = [];
            const today = new Date();
            
            for (let i = 0; i < 30; i++) {
              const date = new Date(today);
              date.setDate(date.getDate() + i);
              promises.push(loadAvailabilityForInjectorDate(cart.id, date, locationName));
            }
            
            return Promise.all(promises);
          });
        })
        .catch(error => {
          console.error(`Failed to load availability for ${locationName}:`, error);
        });
    }
    
    function loadAvailabilityForInjectorDate(cartId, date, locationName) {
      const dateStr = date.toISOString().split('T')[0];
      
      const query = `
        query GetCartBookableTimes($cartId: ID!, $searchDate: Date!) {
          cartBookableTimes(
            id: $cartId,
            searchDate: $searchDate,
            tz: "America/New_York"
          ) {
            id
            startTime
          }
        }
      `;
      
      return makeBoulevardRequest(query, { 
        cartId: cartId, 
        searchDate: dateStr 
      })
        .then(data => {
          const times = data.cartBookableTimes || [];
          
          if (!injectorAvailabilityData[dateStr]) {
            injectorAvailabilityData[dateStr] = {};
          }
          
          injectorAvailabilityData[dateStr][locationName] = times;
          return times;
        })
        .catch(error => {
          console.error('Failed to load availability for', dateStr, locationName, error);
          if (!injectorAvailabilityData[dateStr]) {
            injectorAvailabilityData[dateStr] = {};
          }
          injectorAvailabilityData[dateStr][locationName] = [];
          return [];
        });
    }
    
    function showInjectorAvailabilityCalendar() {
      const container = document.getElementById('messages');
      const calendarMessage = document.createElement('div');
      calendarMessage.className = 'message system';
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      
      // Location legend and toggle (FIRST)
      const legend = document.createElement('div');
      legend.className = 'location-legend';
      
      const legendTitle = document.createElement('div');
      legendTitle.className = 'legend-title';
      legendTitle.textContent = 'Locations (click to toggle):';
      
      const legendItems = document.createElement('div');
      legendItems.className = 'legend-items';
      
      injectorLocations.forEach(locationName => {
        const legendItem = document.createElement('div');
        legendItem.className = 'legend-item';
        if (!visibleLocations.has(locationName)) {
          legendItem.classList.add('inactive');
        }
        
        legendItem.onclick = () => toggleLocationVisibility(locationName, renderInjectorAvailabilityCalendar);
        
        const colorDiv = document.createElement('div');
        colorDiv.className = 'legend-color';
        colorDiv.style.backgroundColor = locationColors[locationName];
        
        const nameDiv = document.createElement('div');
        nameDiv.textContent = locationName;
        
        legendItem.appendChild(colorDiv);
        legendItem.appendChild(nameDiv);
        legendItems.appendChild(legendItem);
      });
      
      legend.appendChild(legendTitle);
      legend.appendChild(legendItems);
      
      // Calendar container (SECOND)
      const availabilityContainer = document.createElement('div');
      availabilityContainer.className = 'availability-container';
      availabilityContainer.id = 'injector-availability-container';
      
      bubble.appendChild(legend);
      bubble.appendChild(availabilityContainer);
      
      calendarMessage.appendChild(bubble);
      container.appendChild(calendarMessage);
      scrollToBottom();
      
      renderInjectorAvailabilityCalendar();
    }
    
    function renderInjectorAvailabilityCalendar() {
      const container = document.getElementById('injector-availability-container');
      container.innerHTML = '';
      
      // Initialize current calendar date if not set
      if (!currentCalendarDate) {
        currentCalendarDate = new Date();
        currentCalendarDate.setDate(1);
        currentCalendarDate.setHours(0, 0, 0, 0);
      }
      
      // Calendar header
      const calendarHeader = document.createElement('div');
      calendarHeader.className = 'calendar-header';
      
      const prevButton = document.createElement('button');
      prevButton.className = 'calendar-nav';
      prevButton.textContent = '← Previous';
      prevButton.onclick = () => navigateInjectorMonth(-1);
      
      const calendarTitle = document.createElement('div');
      calendarTitle.className = 'calendar-title';
      calendarTitle.textContent = `${selectedInjector}'s Availability - ${currentCalendarDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}`;
      
      const nextButton = document.createElement('button');
      nextButton.className = 'calendar-nav';
      nextButton.textContent = 'Next →';
      nextButton.onclick = () => navigateInjectorMonth(1);
      
      calendarHeader.appendChild(prevButton);
      calendarHeader.appendChild(calendarTitle);
      calendarHeader.appendChild(nextButton);
          
      // Calendar grid
      const calendarGrid = document.createElement('div');
      calendarGrid.className = 'calendar-grid';
      
      // Day headers
      const dayHeaders = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      dayHeaders.forEach(day => {
        const dayHeader = document.createElement('div');
        dayHeader.className = 'calendar-day-header';
        dayHeader.textContent = day;
        calendarGrid.appendChild(dayHeader);
      });
      
      // Generate calendar for current month using currentCalendarDate
      const today = new Date();
      const year = currentCalendarDate.getFullYear();
      const month = currentCalendarDate.getMonth();
      const firstDay = new Date(year, month, 1);
      const lastDay = new Date(year, month + 1, 0);
      
      // Add empty cells for days before the first day of the month
      for (let i = 0; i < firstDay.getDay(); i++) {
        const emptyDay = document.createElement('div');
        emptyDay.className = 'calendar-day disabled';
        calendarGrid.appendChild(emptyDay);
      }
      
      // Add days of the month
      for (let day = 1; day <= lastDay.getDate(); day++) {
        const date = new Date(year, month, day);
        const dateStr = date.toISOString().split('T')[0];
        const dayElement = document.createElement('div');
        dayElement.className = 'calendar-day injector-calendar-day';
        
        // Check if day is in the past
        if (date < today) {
          dayElement.classList.add('disabled');
        } else {
          dayElement.onclick = () => selectInjectorDate(date);
        }
        
        const dayNumber = document.createElement('div');
        dayNumber.className = 'day-number';
        dayNumber.textContent = day;
        
        const slotsContainer = document.createElement('div');
        slotsContainer.className = 'calendar-slots';
        
        // Add slot indicators for visible locations
        const dayData = injectorAvailabilityData[dateStr];
        if (dayData) {
          let hasSlots = false;
          
          Object.keys(dayData).forEach(locationName => {
            if (!visibleLocations.has(locationName)) return;
            
            const slots = dayData[locationName];
            if (slots && slots.length > 0) {
              hasSlots = true;
              
              // Show up to 3 slot indicators per location
              const slotsToShow = Math.min(3, slots.length);
              for (let i = 0; i < slotsToShow; i++) {
                const slotIndicator = document.createElement('div');
                slotIndicator.className = 'slot-indicator';
                slotIndicator.style.backgroundColor = locationColors[locationName];
                slotIndicator.title = `${locationName} - ${slots.length} slot${slots.length > 1 ? 's' : ''}`;
                slotsContainer.appendChild(slotIndicator);
              }
            }
          });
          
          if (hasSlots) {
            dayElement.classList.add('has-availability');
          }
        }
        
        dayElement.appendChild(dayNumber);
        dayElement.appendChild(slotsContainer);
        calendarGrid.appendChild(dayElement);
      }
      
      container.appendChild(calendarHeader);
      container.appendChild(calendarGrid);
      
      // Time slots container (initially hidden)
      const timeSlotsContainer = document.createElement('div');
      timeSlotsContainer.className = 'injector-time-slots';
      timeSlotsContainer.id = 'injector-time-slots-container';
      timeSlotsContainer.style.display = 'none';
      container.appendChild(timeSlotsContainer);
    }
    
    function navigateInjectorMonth(direction) {
      if (!currentCalendarDate) {
        currentCalendarDate = new Date();
      }
      currentCalendarDate.setMonth(currentCalendarDate.getMonth() + direction);
      
      // Clear existing availability data
      injectorAvailabilityData = {};
      
      // Show loading message
      const container = document.getElementById('injector-availability-container');
      container.innerHTML = '<div style="text-align: center; padding: 20px; color: #86868b;">Loading availability...</div>';
      
      // Reload availability for new month
      loadInjectorAvailabilityAcrossLocations();
    }
    
    function selectInjectorDate(date) {
      selectedDate = date;
      const dateStr = date.toISOString().split('T')[0];
      
      // Update selected state in calendar
      document.querySelectorAll('.injector-calendar-day').forEach(day => {
        day.classList.remove('selected');
      });
      
      // Find and select the clicked day
      const dayElements = document.querySelectorAll('.injector-calendar-day');
      dayElements.forEach(dayElement => {
        const dayNumber = dayElement.querySelector('.day-number');
        if (dayNumber && parseInt(dayNumber.textContent) === date.getDate()) {
          dayElement.classList.add('selected');
        }
      });
      
      showInjectorTimeSlotsForDate(date);
    }
    
    function showInjectorTimeSlotsForDate(date) {
      const dateStr = date.toISOString().split('T')[0];
      const dayData = injectorAvailabilityData[dateStr];
      
      const timeSlotsContainer = document.getElementById('injector-time-slots-container');
      timeSlotsContainer.innerHTML = '';
      
      if (!dayData) {
        timeSlotsContainer.innerHTML = '<p style="text-align: center; color: #86868b; padding: 20px;">No availability data for this date</p>';
        timeSlotsContainer.style.display = 'block';
        return;
      }
      
      const allSlots = [];
      
      // Collect all slots from visible locations
      Object.keys(dayData).forEach(locationName => {
        if (!visibleLocations.has(locationName)) return;
        
        const slots = dayData[locationName] || [];
        slots.forEach(slot => {
          allSlots.push({
            ...slot,
            locationName: locationName,
            color: locationColors[locationName]
          });
        });
      });
      
      if (allSlots.length === 0) {
        timeSlotsContainer.innerHTML = '<p style="text-align: center; color: #86868b; padding: 20px;">No available times for this date</p>';
      } else {
        // Sort slots by time
        allSlots.sort((a, b) => new Date(a.startTime) - new Date(b.startTime));
        
        allSlots.forEach(slot => {
          const startTime = new Date(slot.startTime);
          const timeStr = startTime.toLocaleTimeString('en-US', {
            hour: 'numeric',
            minute: '2-digit',
            hour12: true
          });
          
          const timeSlot = document.createElement('div');
          timeSlot.className = 'injector-time-slot';
          timeSlot.onclick = () => selectInjectorTimeSlot(slot, timeStr, date.toLocaleDateString('en-US', {
            weekday: 'short',
            month: 'short',
            day: 'numeric'
          }), slot.startTime);
          
          const timeDiv = document.createElement('div');
          timeDiv.className = 'slot-time';
          timeDiv.textContent = timeStr;
          
          const locationDiv = document.createElement('div');
          locationDiv.className = 'slot-location';
          
          const colorDiv = document.createElement('div');
          colorDiv.className = 'slot-location-color';
          colorDiv.style.backgroundColor = slot.color;
          
          const nameDiv = document.createElement('div');
          nameDiv.textContent = slot.locationName;
          
          locationDiv.appendChild(colorDiv);
          locationDiv.appendChild(nameDiv);
          
          timeSlot.appendChild(timeDiv);
          timeSlot.appendChild(locationDiv);
          
          timeSlotsContainer.appendChild(timeSlot);
        });
      }
      
      timeSlotsContainer.style.display = 'block';
      scrollToBottom();
    }
    
    function selectInjectorTimeSlot(slot, timeStr, dateStr, startTime) {
      selectedTime = { id: slot.id, time: timeStr, date: dateStr, startTime: startTime };
      selectedLocation = slot.locationName;
      selectedLocationId = LOCATIONS_DATA[slot.locationName].locationId;
      
      addMessage('user', `${dateStr} at ${timeStr} - ${slot.locationName}`);
      addMessage('system', `Perfect! I've noted your appointment with ${selectedInjector} at ${slot.locationName} on ${dateStr} at ${timeStr}. Let me prepare your booking...`);
      
      // Now we need to create a proper cart for this location and complete the booking
      createCartForInjectorBooking();
    }
    
    function toggleLocationVisibility(locationName, renderFunction) {
      if (visibleLocations.has(locationName)) {
        visibleLocations.delete(locationName);
      } else {
        visibleLocations.add(locationName);
      }
      renderFunction();
    }
    
    function selectInjector(injectorId, injectorName) {
      selectedInjector = injectorName;
      selectedInjectorId = injectorId;
      addMessage('user', injectorName);
      
      const selectedStaff = availableStaff.find(s => s.id === injectorId);
      injectorLocations = selectedStaff ? selectedStaff.locations : [];
      
      addMessage('system', `Great! Let me show you available services with ${selectedInjector}...`, function() {
        loadServicesForInjector();
      });
    }
    
    function loadServicesForInjector() {
      if (injectorLocations.length === 0) {
        showErrorMessage('No locations found for this injector.');
        return;
      }
      
      // Use the first location to load services (assume services are similar across locations)
      const tempLocationName = injectorLocations[0];
      const tempLocationId = LOCATIONS_DATA[tempLocationName].locationId;
      const formattedLocationId = tempLocationId.indexOf('urn:blvd:Location:') === 0 ? 
        tempLocationId : 'urn:blvd:Location:' + tempLocationId;
      
      const query = `
        mutation CreateTempCart($locationId: ID!) {
          createCart(input: { locationId: $locationId }) {
            cart {
              id
              availableCategories {
                availableItems {
                  id
                  name
                  description
                  ... on CartAvailableBookableItem {
                    listPrice
                    listDuration
                    staffVariants {
                      id
                      price
                      duration
                      staff {
                        id
                      }
                    }
                  }
                }
              }
            }
          }
        }
      `;
      
      makeBoulevardRequest(query, { locationId: formattedLocationId })
        .then(data => {
          const cart = data.createCart.cart;
          
          // Filter services that the selected injector can perform
          const services = [];
          cart.availableCategories.forEach(category => {
            category.availableItems.forEach(item => {
              if (item.staffVariants) {
                const variant = item.staffVariants.find(v => v.staff.id === selectedInjectorId);
                if (variant) {
                  services.push({
                    id: item.id,
                    name: item.name,
                    description: item.description,
                    price: item.listPrice,
                    duration: item.listDuration,
                    category: category.name,
                    staffVariantId: variant.id
                  });
                }
              }
            });
          });
          
          if (services.length > 0) {
            availableServices = services;
            showServices();
          } else {
            showErrorMessage('No services available for this injector.');
          }
        })
        .catch(error => {
          console.error('Failed to load services for injector:', error);
          showErrorMessage('Unable to load services. Please try again.');
        });
    }
    
    function selectService(serviceId, serviceName) {
      selectedServiceId = serviceId;
      selectedServiceName = serviceName;
      addMessage('user', serviceName);
      
      addMessage('system', `Great! I've selected ${serviceName}. Now let me find available times with ${selectedInjector}...`, function() {
        loadAvailabilityForInjectorAcrossLocations();
      });
    }
    
    function loadAvailabilityForInjectorAcrossLocations() {
      injectorAvailabilityData = {};
      visibleLocations = new Set(injectorLocations);
      assignLocationColors([{locations: injectorLocations}]);
      
      const promises = injectorLocations.map(locationName => loadAvailabilityForInjectorInLocation(locationName));
      
      Promise.all(promises)
        .then(() => showInjectorAvailabilityCalendar())
        .catch(error => showErrorMessage('Unable to load availability.'));
    }
    
    function loadAvailabilityForInjectorInLocation(locationName) {
      const locationId = LOCATIONS_DATA[locationName].locationId;
      const formattedLocationId = locationId.indexOf('urn:blvd:Location:') === 0 ? locationId : 'urn:blvd:Location:' + locationId;
      
      const createCartQuery = `
        mutation CreateTempCart($locationId: ID!) {
          createCart(input: { locationId: $locationId }) {
            cart {
              id
              availableCategories {
                availableItems {
                  id
                  name
                  ... on CartAvailableBookableItem {
                    staffVariants {
                      id
                      staff {
                        id
                      }
                    }
                  }
                }
              }
            }
          }
        }
      `;
      
      return makeBoulevardRequest(createCartQuery, { locationId: formattedLocationId })
        .then(data => {
          const cart = data.createCart.cart;
          
          // Find the service by name and variant for injector
          let itemId = null;
          let variantId = null;
          for (const category of cart.availableCategories) {
            for (const item of category.availableItems) {
              if (item.name === selectedServiceName && item.staffVariants) {
                const variant = item.staffVariants.find(v => v.staff.id === selectedInjectorId);
                if (variant) {
                  itemId = item.id;
                  variantId = variant.id;
                  break;
                }
              }
            }
            if (itemId) break;
          }
          
          if (!itemId) return;
          
          // Add to cart
          const addQuery = `
            mutation AddCartItem($cartId: ID!, $itemId: ID!, $itemStaffVariantId: ID!) {
              addCartSelectedBookableItem(input: {
                id: $cartId,
                itemId: $itemId,
                itemStaffVariantId: $itemStaffVariantId
              }) {
                cart {
                  id
                }
              }
            }
          `;
          
          return makeBoulevardRequest(addQuery, { cartId: cart.id, itemId, itemStaffVariantId: variantId })
            .then(() => {
              // Load for month
              const promises = [];
              const year = currentCalendarDate.getFullYear();
              const month = currentCalendarDate.getMonth();
              const lastDay = new Date(year, month + 1, 0).getDate();
              
              for (let day = 1; day <= lastDay; day++) {
                const date = new Date(year, month, day);
                if (date >= new Date()) {
                  promises.push(loadAvailabilityForInjectorDate(cart.id, date, locationName));
                }
              }
              return Promise.all(promises);
            });
        });
    }
    
    function selectLocation(location) {
      selectedLocation = location;
      selectedLocationId = LOCATIONS_DATA[location].locationId;
      addMessage('user', location);
      
      addMessage('system', `Perfect! Creating your booking session for ${location}...`, function() {
        createCart();
      });
    }
    
    function createCart() {
      const formattedLocationId = selectedLocationId.indexOf('urn:blvd:Location:') === 0 ? 
        selectedLocationId : 'urn:blvd:Location:' + selectedLocationId;
      
      const query = `
        mutation CreateCart($locationId: ID!) {
          createCart(input: { locationId: $locationId }) {
            cart {
              id
              expiresAt
              availableCategories {
                availableItems {
                  id
                  name
                  description
                  ... on CartAvailableBookableItem {
                    listPrice
                    listDuration
                    staffVariants {
                      id
                      price
                      duration
                      staff {
                        id
                        firstName
                        lastName
                      }
                    }
                  }
                }
              }
            }
          }
        }
      `;
      
      makeBoulevardRequest(query, { locationId: formattedLocationId })
        .then(data => {
          if (!data || !data.createCart || !data.createCart.cart) {
            throw new Error('Invalid cart creation response');
          }
          
          cartId = data.createCart.cart.id;
          loadServices(data.createCart.cart);
        })
        .catch(error => {
          showErrorMessage('Unable to create booking session. Please try again.', true);
        });
    }
    
    function loadServices(cart) {
      const categories = cart.availableCategories || [];
      const services = [];
      
      for (const category of categories) {
        let categoryItems = category.availableItems || [];
        
        // Filter services based on treatment type
        if (treatmentType === 'injectable') {
          categoryItems = categoryItems.filter(item => {
            const itemName = item.name.toLowerCase();
            const categoryName = category.name.toLowerCase();
            return itemName.includes('botox') ||
                   itemName.includes('filler') ||
                   itemName.includes('inject') ||
                   itemName.includes('dysport') ||
                   itemName.includes('restylane') ||
                   itemName.includes('juvederm') ||
                   categoryName.includes('inject') ||
                   categoryName.includes('neuro') ||
                   categoryName.includes('filler');
          });
        } else if (treatmentType === 'skin') {
          categoryItems = categoryItems.filter(item => {
            const itemName = item.name.toLowerCase();
            const categoryName = category.name.toLowerCase();
            return itemName.includes('laser') ||
                   itemName.includes('microneedling') ||
                   itemName.includes('facial') ||
                   itemName.includes('peel') ||
                   itemName.includes('hydrafacial') ||
                   itemName.includes('dermaplaning') ||
                   categoryName.includes('skin') ||
                   categoryName.includes('facial') ||
                   categoryName.includes('laser');
          });
        }
        
        for (const item of categoryItems) {
          let staffVariants = item.staffVariants || [];
          
          if (selectedInjectorId && selectedInjectorId !== 'first-available') {
            staffVariants = staffVariants.filter(v => v.staff.id === selectedInjectorId);
          }
          
          if (staffVariants.length > 0 || (!selectedInjectorId || selectedInjectorId === 'first-available')) {
            services.push({
              id: item.id,
              name: item.name,
              description: item.description,
              price: item.listPrice,
              duration: item.listDuration,
              category: category.name,
              staffVariants: staffVariants
            });
          }
        }
      }
      
      if (services.length > 0) {
        availableServices = services;
        
        showServices();
      } else {
        showServiceFallback();
      }
    }
    
    function showServices() {
      const treatmentLabel = treatmentType === 'injectable' ? 'injectable treatments' : 'skin treatments';
      addMessage('system', `Here are the available ${treatmentLabel} at ${selectedLocation}:`, function() {
        const container = document.getElementById('messages');
        const serviceMessage = document.createElement('div');
        serviceMessage.className = 'message system';
        
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble';
        
        const grid = document.createElement('div');
        grid.className = 'service-grid';
        
        availableServices.forEach(service => {
          const button = document.createElement('button');
          button.className = 'service-button';
          button.onclick = () => selectService(service.id, service.name);
          
          const serviceInfo = document.createElement('div');
          serviceInfo.className = 'service-info';
          
          const nameDiv = document.createElement('div');
          nameDiv.className = 'service-name';
          nameDiv.textContent = service.name;
          
          const durationDiv = document.createElement('div');
          durationDiv.className = 'service-duration';
          durationDiv.textContent = service.duration ? `${service.duration} minutes` : '';
          
          serviceInfo.appendChild(nameDiv);
          serviceInfo.appendChild(durationDiv);
          
          const priceDiv = document.createElement('div');
          priceDiv.className = 'service-price';
          priceDiv.textContent = service.price ? `$${Math.round(service.price / 100)}` : 'Contact for pricing';
          
          button.appendChild(serviceInfo);
          button.appendChild(priceDiv);
          grid.appendChild(button);
        });
        
        bubble.appendChild(grid);
        
        const smsButton = document.createElement('button');
        smsButton.className = 'secondary-button';
        smsButton.textContent = "Don't see what you're looking for? Contact us";
        smsButton.onclick = () => openSMS('service-inquiry');
        bubble.appendChild(smsButton);
        
        serviceMessage.appendChild(bubble);
        container.appendChild(serviceMessage);
        scrollToBottom();
      });
    }
    
    function selectService(serviceId, serviceName) {
      selectedService = serviceName;
      selectedServiceId = serviceId;
      addMessage('user', serviceName);
      
      addMessage('system', `Great! I've added ${serviceName} to your booking. Now let me find available appointment times...`);
      addServiceToCart();
    }
    
    function addServiceToCart() {
      const mutation = `
        mutation AddCartItem($cartId: ID!, $itemId: ID!, $itemStaffVariantId: ID) {
          addCartSelectedBookableItem(input: {
            id: $cartId,
            itemId: $itemId,
            itemStaffVariantId: $itemStaffVariantId
          }) {
            cart {
              id
              selectedItems {
                id
              }
            }
          }
        }
      `;
      
      const variables = { 
        cartId: cartId, 
        itemId: selectedServiceId 
      };
      
      // Add staff variant if we have a specific injector selected
      if (selectedInjectorId && selectedInjectorId !== 'first-available') {
        console.log('🎯 Looking for staff variant for injector:', selectedInjectorId);
        
        // Find the staff variant for the selected injector from the selected service
        const selectedServiceData = availableServices.find(s => s.id === selectedServiceId);
        console.log('🎯 Selected service data:', selectedServiceData);
        
        if (selectedServiceData && selectedServiceData.staffVariants) {
          const staffVariant = selectedServiceData.staffVariants.find(v => 
            v.staff && v.staff.id === selectedInjectorId
          );
          
          if (staffVariant) {
            console.log('🎯 Found staff variant:', staffVariant);
            variables.itemStaffVariantId = staffVariant.id;
          } else {
            console.log('🎯 No staff variant found for injector, will use first available');
          }
        }
      }
      
      console.log('🎯 Adding service to cart with variables:', variables);
      
      makeBoulevardRequest(mutation, variables)
        .then(data => {
          console.log('Service added to cart');
   loadCalendarAvailability();
        })
        .catch(error => {
          console.error('Failed to add service:', error.message);
          showErrorFallback('Unable to add service. Please try again or contact us.');
        });
    }
    function showClientSelection() {
  const container = document.getElementById('messages');
  const clientMessage = document.createElement('div');
  clientMessage.className = 'message system';
  
  const bubble = document.createElement('div');
  bubble.className = 'message-bubble';
  
  const grid = document.createElement('div');
  grid.className = 'treatment-grid';
  grid.style.gridTemplateColumns = '1fr'; // Stack vertically for 3 options
  
  // Existing client button
  const existingClientButton = document.createElement('button');
  existingClientButton.className = 'treatment-button';
  existingClientButton.onclick = () => selectClientType('existing');
  
  const existingClientTitle = document.createElement('div');
  existingClientTitle.className = 'treatment-title';
  existingClientTitle.textContent = 'Existing Client';
  
  const existingClientDesc = document.createElement('div');
  existingClientDesc.className = 'treatment-desc';
  existingClientDesc.textContent = 'I\'ve been to Get Plump before';
  
  existingClientButton.appendChild(existingClientTitle);
  existingClientButton.appendChild(existingClientDesc);
  
  // New client button
  const newClientButton = document.createElement('button');
  newClientButton.className = 'treatment-button';
  newClientButton.onclick = () => selectClientType('new');
  
  const newClientTitle = document.createElement('div');
  newClientTitle.className = 'treatment-title';
  newClientTitle.textContent = 'New Client';
  
  const newClientDesc = document.createElement('div');
  newClientDesc.className = 'treatment-desc';
  newClientDesc.textContent = 'First time at Get Plump';
  
  newClientButton.appendChild(newClientTitle);
  newClientButton.appendChild(newClientDesc);
  
  // Member button (special styling)
  const memberButton = document.createElement('button');
  memberButton.className = 'treatment-button member-button';
  memberButton.onclick = () => selectClientType('member');
  
  const memberTitle = document.createElement('div');
  memberTitle.className = 'treatment-title';
  memberTitle.textContent = 'Member';
  
  const memberDesc = document.createElement('div');
  memberDesc.className = 'treatment-desc';
  memberDesc.textContent = 'I\'m a Get Plump member';
  
  memberButton.appendChild(memberTitle);
  memberButton.appendChild(memberDesc);
  
  grid.appendChild(existingClientButton);
  grid.appendChild(newClientButton);
  grid.appendChild(memberButton);
  
  bubble.appendChild(grid);
  clientMessage.appendChild(bubble);
  container.appendChild(clientMessage);
  scrollToBottom();
}

function selectClientType(clientType) {
  const clientTypeNames = {
    'existing': 'Existing Client',
    'new': 'New Client', 
    'member': 'Member'
  };
  
  addMessage('user', clientTypeNames[clientType]);
  
  // Store client type for later use
  clientInfo.clientType = clientType;
  
  let message = 'Perfect!';
  if (clientType === 'new') {
    message = 'Perfect! As a new client, you\'ll receive our new client special pricing.';
  } else if (clientType === 'member') {
    message = 'Welcome back! Applying your member benefits.';
  }
  
  // Continue based on treatment type
  if (treatmentType === 'injectable') {
    addMessage('system', message + ' For injectable treatments, would you like to book with a specific injector or choose a location first?', function() {
      showInjectableBookingFlow();
    });
  } else if (treatmentType === 'skin') {
    addMessage('system', message + ' Please select your preferred location:', function() {
      showLocationSelection();
    });
  }
}
    
    function loadCalendarAvailability() {
      const container = document.getElementById('messages');
      const availabilityMessage = document.createElement('div');
      availabilityMessage.className = 'message system';
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      bubble.textContent = 'Here are the available appointment times:';
      
      const availabilityContainer = document.createElement('div');
      availabilityContainer.className = 'availability-container';
      availabilityContainer.id = 'availability-container';
      
      bubble.appendChild(availabilityContainer);
      
      availabilityMessage.appendChild(bubble);
      container.appendChild(availabilityMessage);
      scrollToBottom();
      
      renderCalendar();
      loadAvailabilityForMonth();
    }
    
    function renderCalendar() {
      const container = document.getElementById('availability-container');
      container.innerHTML = '';
      
      // Calendar header
      const calendarHeader = document.createElement('div');
      calendarHeader.className = 'calendar-header';
      
      const prevButton = document.createElement('button');
      prevButton.className = 'calendar-nav';
      prevButton.textContent = '← Previous';
      prevButton.onclick = () => navigateMonth(-1);
      
      const calendarTitle = document.createElement('div');
      calendarTitle.className = 'calendar-title';
      calendarTitle.textContent = currentCalendarDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
      
      const nextButton = document.createElement('button');
      nextButton.className = 'calendar-nav';
      nextButton.textContent = 'Next →';
      nextButton.onclick = () => navigateMonth(1);
      
      calendarHeader.appendChild(prevButton);
      calendarHeader.appendChild(calendarTitle);
      calendarHeader.appendChild(nextButton);
      
      // Calendar grid
      const calendarGrid = document.createElement('div');
      calendarGrid.className = 'calendar-grid';
      
      // Day headers
      const dayHeaders = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      dayHeaders.forEach(day => {
        const dayHeader = document.createElement('div');
        dayHeader.className = 'calendar-day-header';
        dayHeader.textContent = day;
        calendarGrid.appendChild(dayHeader);
      });
      
      // Generate calendar for current month
      const today = new Date();
      const year = currentCalendarDate.getFullYear();
      const month = currentCalendarDate.getMonth();
      const firstDay = new Date(year, month, 1);
      const lastDay = new Date(year, month + 1, 0);
      
      // Add empty cells
      for (let i = 0; i < firstDay.getDay(); i++) {
        const emptyDay = document.createElement('div');
        emptyDay.className = 'calendar-day disabled';
        calendarGrid.appendChild(emptyDay);
      }
      
      // Add days
      for (let day = 1; day <= lastDay.getDate(); day++) {
        const date = new Date(year, month, day);
        const dateStr = date.toISOString().split('T')[0];
        const dayElement = document.createElement('div');
        dayElement.className = 'calendar-day';
        
        if (date < today) {
          dayElement.classList.add('disabled');
        } else {
          dayElement.onclick = () => selectCalendarDate(date);
          
          if (calendarAvailability[dateStr] && calendarAvailability[dateStr].length > 0) {
            dayElement.classList.add('has-availability');
          }
        }
        
        const dayNumber = document.createElement('div');
        dayNumber.className = 'day-number';
        dayNumber.textContent = day;
        
        const dayAvailability = document.createElement('div');
        dayAvailability.className = 'day-availability';
        if (calendarAvailability[dateStr] && calendarAvailability[dateStr].length > 0) {
          dayAvailability.textContent = `${calendarAvailability[dateStr].length} slots`;
        }
        
        dayElement.appendChild(dayNumber);
        dayElement.appendChild(dayAvailability);
        calendarGrid.appendChild(dayElement);
      }
      
      container.appendChild(calendarHeader);
      container.appendChild(calendarGrid);
      
      // Time slots container
      const timeSlotsContainer = document.createElement('div');
      timeSlotsContainer.className = 'time-slots';
      timeSlotsContainer.id = 'time-slots';
      timeSlotsContainer.style.display = 'none';
      container.appendChild(timeSlotsContainer);
    }
    
    function navigateMonth(direction) {
      currentCalendarDate.setMonth(currentCalendarDate.getMonth() + direction);
      calendarAvailability = {};
      renderCalendar();
      loadAvailabilityForMonth();
    }
    
    function loadAvailabilityForMonth() {
      const year = currentCalendarDate.getFullYear();
      const month = currentCalendarDate.getMonth();
      const lastDay = new Date(year, month + 1, 0).getDate();
      
      for (let day = 1; day <= lastDay; day++) {
        const date = new Date(year, month, day);
        if (date >= new Date()) {
          loadAvailabilityForDate(date);
        }
      }
    }
    
    function loadAvailabilityForDate(date) {
      const dateStr = date.toISOString().split('T')[0];
      
      const query = `
        query GetCartBookableTimes($cartId: ID!, $searchDate: Date!) {
          cartBookableTimes(
            id: $cartId,
            searchDate: $searchDate,
            tz: "America/New_York"
          ) {
            id
            startTime
          }
        }
      `;
      
      makeBoulevardRequest(query, { cartId: cartId, searchDate: dateStr })
        .then(data => {
          calendarAvailability[dateStr] = data.cartBookableTimes || [];
          renderCalendar(); // Re-render to update availability indicators
        })
        .catch(error => {
          console.error('Failed to load availability for date', dateStr, error);
          calendarAvailability[dateStr] = [];
          renderCalendar();
        });
    }
    
    function selectCalendarDate(date) {
      selectedDate = date;
      const dateStr = date.toISOString().split('T')[0];
      
      // Update selected state
      document.querySelectorAll('.calendar-day').forEach(day => day.classList.remove('selected'));
      
      const dayElements = document.querySelectorAll('.calendar-day');
      dayElements.forEach(dayElement => {
        const dayNumber = dayElement.querySelector('.day-number');
        if (dayNumber && parseInt(dayNumber.textContent) === date.getDate()) {
          dayElement.classList.add('selected');
        }
      });
      
      showTimeSlotsForDate(date);
    }
    
    function showTimeSlotsForDate(date) {
      const dateStr = date.toISOString().split('T')[0];
      const times = calendarAvailability[dateStr] || [];
      
      const timeSlotsContainer = document.getElementById('time-slots');
      timeSlotsContainer.innerHTML = '';
      timeSlotsContainer.style.display = 'block';
      
      if (times.length === 0) {
        timeSlotsContainer.innerHTML = '<p style="text-align: center; color: #86868b; padding: 20px;">No available times for this date</p>';
      } else {
        times.forEach(time => {
          const startTime = new Date(time.startTime);
          const timeStr = startTime.toLocaleTimeString('en-US', {
            hour: 'numeric',
            minute: '2-digit',
            hour12: true
          });
          
          const timeSlot = document.createElement('div');
          timeSlot.className = 'time-slot';
          timeSlot.textContent = timeStr;
          timeSlot.onclick = () => selectTime(time.id, timeStr, date.toLocaleDateString('en-US', {
            weekday: 'short',
            month: 'short',
            day: 'numeric'
          }), time.startTime);
          
          timeSlotsContainer.appendChild(timeSlot);
        });
      }
      
      scrollToBottom();
    }
    
    function selectTime(timeId, timeStr, dateStr, startTime) {
      selectedTime = { id: timeId, time: timeStr, date: dateStr, startTime: startTime };
      addMessage('user', `${dateStr} at ${timeStr}`);
      
      addMessage('system', `Perfect! I've noted your preferred time: ${dateStr} at ${timeStr}. Let me reserve this time slot...`);
      reserveTimeSlot();
    }
    
    function reserveTimeSlot() {
      const mutation = `
        mutation ReserveCartBookableItems($cartId: ID!, $bookableTimeId: ID!) {
          reserveCartBookableItems(input: {
            id: $cartId,
            bookableTimeId: $bookableTimeId
          }) {
            cart {
              id
            }
          }
        }
      `;
      
      makeBoulevardRequest(mutation, {
        cartId: cartId,
        bookableTimeId: selectedTime.id
      })
        .then(() => {
          addMessage('system', 'Time slot reserved! Now please provide your information to complete the booking.');
          showClientInfoForm();
        })
        .catch(error => {
          console.error('Failed to reserve time slot:', error);
          showErrorMessage('Unable to reserve the time slot. Please try a different time.');
        });
    }
    
    function showClientInfoForm() {
      const container = document.getElementById('messages');
      const formMessage = document.createElement('div');
      formMessage.className = 'message system';
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      
      const formContainer = document.createElement('div');
      formContainer.className = 'form-container';
      
      const title = document.createElement('div');
      title.className = 'form-section-title';
      title.textContent = 'Your Information';
      
      const row = document.createElement('div');
      row.className = 'form-row';
      
      const firstName = document.createElement('input');
      firstName.type = 'text';
      firstName.className = 'form-input';
      firstName.id = 'firstName';
      firstName.placeholder = 'First Name';
      
      const lastName = document.createElement('input');
      lastName.type = 'text';
      lastName.className = 'form-input';
      lastName.id = 'lastName';
      lastName.placeholder = 'Last Name';
      
      row.appendChild(firstName);
      row.appendChild(lastName);
      
      const email = document.createElement('input');
      email.type = 'email';
      email.className = 'form-input';
      email.id = 'email';
      email.placeholder = 'Email Address';
      
      const phone = document.createElement('input');
      phone.type = 'tel';
      phone.className = 'form-input';
      phone.id = 'phone';
      phone.placeholder = 'Phone Number';
      
      const submitButton = document.createElement('button');
      submitButton.className = 'primary-button';
      submitButton.textContent = 'Complete Booking';
      submitButton.onclick = completeBooking;
      
      formContainer.appendChild(title);
      formContainer.appendChild(row);
      formContainer.appendChild(email);
      formContainer.appendChild(phone);
      formContainer.appendChild(submitButton);
      
      bubble.appendChild(formContainer);
      formMessage.appendChild(bubble);
      container.appendChild(formMessage);
      scrollToBottom();
    }
    
    function completeBooking() {
      const firstName = document.getElementById('firstName').value.trim();
      const lastName = document.getElementById('lastName').value.trim();
      const email = document.getElementById('email').value.trim();
      const phone = document.getElementById('phone').value.trim();
      
      // Clear previous errors
      document.querySelectorAll('.form-input').forEach(input => input.classList.remove('error'));
      document.querySelectorAll('.error-text').forEach(error => error.remove());
      
      let hasErrors = false;
      
      if (!firstName) {
        showFieldError('firstName', 'First name is required');
        hasErrors = true;
      }
      
      if (!lastName) {
        showFieldError('lastName', 'Last name is required');
        hasErrors = true;
      }
      
      if (!email || !validateEmail(email)) {
        showFieldError('email', 'Valid email is required');
        hasErrors = true;
      }
      
      if (!phone || !validatePhoneNumber(phone)) {
        showFieldError('phone', 'Valid phone number is required');
        hasErrors = true;
      }
      
      if (hasErrors) return;
      
      clientInfo = { firstName, lastName, email, phoneNumber: phone };
      
      const button = document.querySelector('.primary-button');
      button.textContent = 'Completing...';
      button.disabled = true;
      
      updateCartWithClientInfo()
        .then(() => completeAPIBooking())
        .then(result => {
          showBookingSuccess(result);
        })
        .catch(error => {
          console.error('Booking failed:', error);
          showErrorMessage('Unable to complete booking. Please try again.');
          button.textContent = 'Complete Booking';
          button.disabled = false;
        });
    }
    
    function updateCartWithClientInfo() {
      const mutation = `
        mutation UpdateCart($input: UpdateCartInput!) {
          updateCart(input: $input) {
            cart {
              id
            }
          }
        }
      `;
      
      const input = {
        id: cartId,
        clientInformation: {
          firstName: clientInfo.firstName,
          lastName: clientInfo.lastName,
          email: clientInfo.email,
          phoneNumber: clientInfo.phoneNumber
        }
      };
      
      return makeBoulevardRequest(mutation, { input });
    }
    
    function showFieldError(fieldId, message) {
      const field = document.getElementById(fieldId);
      field.classList.add('error');
      
      const errorDiv = document.createElement('div');
      errorDiv.className = 'error-text';
      errorDiv.textContent = message;
      
      field.parentNode.insertBefore(errorDiv, field.nextSibling);
    }
    
    function showErrorMessage(message) {
      const container = document.getElementById('messages');
      const errorMessage = document.createElement('div');
      errorMessage.className = 'message system';
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      bubble.innerHTML = `<div class="error-message">${message}</div>`;
      
      errorMessage.appendChild(bubble);
      container.appendChild(errorMessage);
      scrollToBottom();
    }
    
    function showBookingSuccess(result) {
      const injectorText = selectedInjector ? ` with ${selectedInjector}` : '';
      
      addMessage('system', `Booking completed! Your appointment for ${selectedService} on ${selectedTime.date} at ${selectedTime.time}${injectorText} at ${selectedLocation} is confirmed.`);
    }
    
    function restartChat() {
      startConversation();
    }
    
    function scrollToBottom() {
      const container = document.getElementById('messages');
      container.scrollTop = container.scrollHeight;
    }
  </script>
</body>
</html>

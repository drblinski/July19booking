<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Book Appointment | Get Plump</title>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: #f5f5f7;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }
    
    .booking-widget {
      width: 100%;
      max-width: 800px;
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      height: 80vh;
      min-height: 600px;
    }
    
    .chat-header {
      background: #ffffff;
      padding: 20px 30px;
      border-bottom: 1px solid #e5e5e7;
      text-align: center;
    }
    
    .chat-title {
      color: #1d1d1f;
      font-size: 1.3rem;
      font-weight: 600;
      margin-bottom: 5px;
    }
    
    .chat-subtitle {
      color: #86868b;
      font-size: 0.95rem;
    }
    
    .messages-container {
      flex: 1;
      padding: 20px 30px;
      overflow-y: auto;
      scroll-behavior: smooth;
      background: #fff;
    }
    
    .message {
      margin-bottom: 20px;
      display: flex;
      animation: slideIn 0.3s ease-out;
      max-width: 100%;
    }
    
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .message.system {
      justify-content: flex-start;
    }
    
    .message.user {
      justify-content: flex-end;
    }
    
    .message-bubble {
      max-width: 70%;
      padding: 12px 18px;
      border-radius: 18px;
      font-size: 1rem;
      line-height: 1.4;
      word-wrap: break-word;
    }
    
    .message.system .message-bubble {
      background: #e9e9eb;
      color: #1d1d1f;
      border-bottom-left-radius: 4px;
    }
    
    .message.user .message-bubble {
      background: #007AFF;
      color: #fff;
      border-bottom-right-radius: 4px;
    }
    
    .typing-indicator {
      display: flex;
      align-items: center;
      padding: 12px 18px;
      background: #e9e9eb;
      border-radius: 18px;
      border-bottom-left-radius: 4px;
      max-width: 80px;
    }
    
    .typing-dots {
      display: flex;
      gap: 4px;
    }
    
    .dot {
      width: 8px;
      height: 8px;
      background: #86868b;
      border-radius: 50%;
      animation: typing 1.4s infinite;
    }
    
    .dot:nth-child(2) { animation-delay: 0.2s; }
    .dot:nth-child(3) { animation-delay: 0.4s; }
    
    @keyframes typing {
      0%, 60%, 100% { transform: translateY(0); opacity: 0.5; }
      30% { transform: translateY(-6px); opacity: 1; }
    }
    
    /* Treatment Type Selection */
    .treatment-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-top: 15px;
    }
    
    .treatment-button {
      background: #fff;
      border: 2px solid #e5e5e7;
      color: #1d1d1f;
      padding: 20px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
      font-size: 1rem;
      font-weight: 500;
    }
    
    .treatment-button:hover {
      border-color: #007AFF;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 122, 255, 0.15);
    }
    .member-button {
  background: #1d1d1f !important;
  color: #fff !important;
  border-color: #1d1d1f !important;
}

.member-button:hover {
  background: #000 !important;
  border-color: #000 !important;
  color: #fff !important;
}

.member-button .treatment-desc {
  color: rgba(255, 255, 255, 0.8) !important;
}
    
    .treatment-title {
      font-weight: 600;
      margin-bottom: 8px;
      font-size: 1.1rem;
    }
    
    .treatment-desc {
      font-size: 0.9rem;
      color: #86868b;
      line-height: 1.3;
    }
    
    /* Improved Injector Display - Vertical List */
    .injector-container {
      margin-top: 15px;
    }
    
    .injector-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-height: 300px;
      overflow-y: auto;
      padding-right: 5px;
    }
    
    .injector-list::-webkit-scrollbar {
      width: 6px;
    }
    
    .injector-list::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 3px;
    }
    
    .injector-list::-webkit-scrollbar-thumb {
      background: #c1c1c1;
      border-radius: 3px;
    }
    
    .injector-list::-webkit-scrollbar-thumb:hover {
      background: #a8a8a8;
    }
    
    .injector-item {
      background: #fff;
      border: 2px solid #e5e5e7;
      border-radius: 25px;
      padding: 8px 16px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 12px;
      min-height: 50px;
    }
    
    .injector-item:hover {
      border-color: #007AFF;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0, 122, 255, 0.15);
    }
    
    .injector-item.first-available {
      background: #007AFF;
      color: #fff;
      border-color: #007AFF;
    }
    
    .injector-item.first-available:hover {
      background: #0056d6;
      border-color: #0056d6;
    }
    
    .injector-photo {
      width: 35px;
      height: 35px;
      border-radius: 50%;
      background: #e5e5e7;
      background-size: cover;
      background-position: center;
      flex-shrink: 0;
    }
    
    .injector-name {
      font-weight: 600;
      font-size: 0.95rem;
      flex: 1;
      text-align: left;
    }
    
    .injector-item.first-available .injector-name {
      color: #fff;
    }
    
    /* Calendar-style Time Selection */
    .availability-container {
      margin-top: 15px;
    }
    
    .calendar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding: 0 10px;
    }
    
    .calendar-nav {
      background: #f0f0f0;
      border: none;
      border-radius: 8px;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s ease;
    }
    
    .calendar-nav:hover {
      background: #e0e0e0;
    }
    
    .calendar-nav:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .calendar-title {
      font-weight: 600;
      font-size: 1rem;
      color: #1d1d1f;
    }
    
    .calendar-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 8px;
      margin-bottom: 15px;
    }
    
    .calendar-day-header {
      text-align: center;
      font-size: 0.8rem;
      color: #86868b;
      font-weight: 500;
      padding: 8px 4px;
    }
    
    .calendar-day {
      background: #f9f9f9;
      border: 1px solid #e5e5e7;
      border-radius: 8px;
      padding: 8px 4px;
      text-align: center;
      font-size: 0.85rem;
      min-height: 60px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }
    
    .calendar-day:hover {
      background: #f0f8ff;
      border-color: #007AFF;
    }
    
    .calendar-day.has-availability {
      background: #fff;
      border-color: #34c759;
    }
    
    .calendar-day.has-availability:hover {
      background: #f0fff4;
      border-color: #30a752;
    }
    
    .calendar-day.selected {
      background: #007AFF;
      color: #fff;
      border-color: #007AFF;
    }
    
    .calendar-day.disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    
    .calendar-day.disabled:hover {
      background: #f9f9f9;
      border-color: #e5e5e7;
    }
    
    .day-number {
      font-weight: 500;
      margin-bottom: 2px;
    }
    
    .day-availability {
      font-size: 0.7rem;
      color: #34c759;
      font-weight: 500;
    }
    
    .calendar-day.selected .day-availability {
      color: rgba(255, 255, 255, 0.8);
    }
    
    .time-slots {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 8px;
      max-height: 200px;
      overflow-y: auto;
      padding: 10px;
      background: #f9f9f9;
      border-radius: 8px;
    }
    
    .time-slot {
      background: #fff;
      border: 1px solid #e5e5e7;
      border-radius: 6px;
      padding: 8px;
      text-align: center;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .time-slot:hover {
      background: #f0f8ff;
      border-color: #007AFF;
    }
    
    /* Location Grid */
    .location-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-top: 15px;
    }
    
    .location-button {
      background: #fff;
      border: 2px solid #e5e5e7;
      color: #1d1d1f;
      padding: 15px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
      font-size: 0.95rem;
      font-weight: 500;
    }
    
    .location-button:hover {
      border-color: #007AFF;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 122, 255, 0.15);
    }
    
    /* Service Grid */
    .service-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      margin-top: 15px;
      max-height: 350px;
      overflow-y: auto;
    }
    
    .service-button {
      background: #fff;
      border: 2px solid #e5e5e7;
      color: #1d1d1f;
      padding: 18px 20px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: left;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .service-button:hover {
      border-color: #007AFF;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0, 122, 255, 0.15);
    }
    
    .service-info {
      flex: 1;
    }
    
    .service-name {
      font-weight: 600;
      margin-bottom: 4px;
      font-size: 1rem;
    }
    
    .service-duration {
      font-size: 0.85rem;
      color: #86868b;
    }
    
    .service-price {
      font-size: 1rem;
      font-weight: 600;
      color: #007AFF;
    }
    
    /* Form Container */
    .form-container {
      background: #f9f9f9;
      border-radius: 12px;
      padding: 25px;
      margin-top: 15px;
    }
    
    .form-input {
      width: 100%;
      background: #fff;
      border: 2px solid #e5e5e7;
      border-radius: 8px;
      padding: 12px 16px;
      color: #1d1d1f;
      font-size: 1rem;
      margin-bottom: 15px;
      transition: border-color 0.2s ease;
    }
    
    .form-input::placeholder {
      color: #86868b;
    }
    
    .form-input:focus {
      outline: none;
      border-color: #007AFF;
    }
    
    .form-input.error {
      border-color: #ff3b30;
    }
    
    .error-text {
      color: #ff3b30;
      font-size: 0.85rem;
      margin-top: -10px;
      margin-bottom: 10px;
    }
    
    .form-section-title {
      color: #1d1d1f;
      font-weight: 600;
      margin-bottom: 15px;
      margin-top: 20px;
      font-size: 1.1rem;
    }
    
    .form-section-title:first-child {
      margin-top: 0;
    }
    
    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
    }
    
    /* Buttons */
    .primary-button {
      background: #007AFF;
      color: #fff;
      border: none;
      padding: 15px 25px;
      border-radius: 25px;
      font-weight: 600;
      cursor: pointer;
      margin-top: 20px;
      width: 100%;
      font-size: 1rem;
      transition: all 0.2s ease;
    }
    
    .primary-button:hover {
      background: #0056d6;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3);
    }
    
    .primary-button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }
    
    .secondary-button {
      background: #34c759;
      color: #fff;
      border: none;
      padding: 12px 20px;
      border-radius: 20px;
      font-weight: 500;
      cursor: pointer;
      margin-top: 15px;
      width: 100%;
      font-size: 0.95rem;
      transition: all 0.2s ease;
    }
    
    .secondary-button:hover {
      background: #30a752;
      transform: translateY(-1px);
    }
    
    .restart-button {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #fff;
      border: 2px solid #e5e5e7;
      color: #1d1d1f;
      padding: 8px 16px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.2s ease;
      z-index: 1000;
      font-weight: 500;
    }
    
    .restart-button:hover {
      border-color: #007AFF;
      background: #f0f8ff;
    }
    
    .error-message {
      background: #ffebee;
      border: 2px solid #ffcdd2;
      color: #d32f2f;
      padding: 15px 18px;
      border-radius: 12px;
      margin-top: 15px;
      font-size: 0.95rem;
    }
    
    .success-message {
      background: #e8f5e8;
      border: 2px solid #c8e6c9;
      color: #2e7d32;
      padding: 15px 18px;
      border-radius: 12px;
      margin-top: 15px;
      font-size: 0.95rem;
    }
    
    .loading {
      opacity: 0.6;
      pointer-events: none;
    }
    
    /* Mobile Responsiveness */
    @media (max-width: 768px) {
      body {
        padding: 0;
        align-items: stretch;
      }
      
      .booking-widget {
        max-width: 100%;
        border-radius: 0;
        height: 100vh;
      }
      
      .messages-container {
        padding: 15px 20px;
      }
      
      .chat-header {
        padding: 15px 20px;
      }
      
      .treatment-grid {
        grid-template-columns: 1fr;
      }
      
      .form-row {
        grid-template-columns: 1fr;
      }
      
      .message-bubble {
        max-width: 85%;
      }
      
      .calendar-grid {
        grid-template-columns: repeat(7, 1fr);
        gap: 4px;
      }
      
      .calendar-day {
        min-height: 50px;
        padding: 4px 2px;
        font-size: 0.8rem;
      }
      
      .injector-list {
        gap: 8px;
        max-height: 250px;
      }
      
      .injector-item {
        padding: 6px 12px;
        min-height: 45px;
        gap: 10px;
      }
      
      .injector-photo {
        width: 30px;
        height: 30px;
      }
      
      .injector-name {
        font-size: 0.9rem;
      }
    }
    
    /* Injector Availability Styles */
    .location-legend {
      background: #f9f9f9;
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
    }
    
    .legend-title {
      font-weight: 600;
      margin-bottom: 10px;
      color: #1d1d1f;
      font-size: 0.95rem;
    }
    
    .legend-items {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 5px 10px;
      background: #fff;
      border-radius: 15px;
      border: 2px solid #e5e5e7;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.85rem;
    }
    
    .legend-item:hover {
      border-color: #007AFF;
      transform: translateY(-1px);
    }
    
    .legend-item.inactive {
      opacity: 0.5;
      background: #f5f5f5;
    }
    
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      flex-shrink: 0;
    }
    
    .injector-calendar-day {
      position: relative;
    }
    
    .calendar-slots {
      display: flex;
      flex-direction: column;
      gap: 2px;
      margin-top: 4px;
    }
    
    .slot-indicator {
      height: 3px;
      border-radius: 1px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .slot-indicator:hover {
      height: 5px;
      transform: translateY(-1px);
    }
    
    .slot-tooltip {
      position: absolute;
      background: #1d1d1f;
      color: #fff;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.75rem;
      white-space: nowrap;
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transform: translateY(-10px);
      transition: all 0.2s ease;
    }
    
    .slot-tooltip.visible {
      opacity: 1;
      transform: translateY(-5px);
    }
    
    .slot-tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 4px solid transparent;
      border-top-color: #1d1d1f;
    }
    
    .injector-time-slots {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
      max-height: 250px;
      overflow-y: auto;
      padding: 10px;
      background: #f9f9f9;
      border-radius: 8px;
      margin-top: 15px;
    }
    
    .injector-time-slot {
      background: #fff;
      border: 2px solid #e5e5e7;
      border-radius: 8px;
      padding: 10px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }
    
    .injector-time-slot:hover {
      border-color: #007AFF;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0, 122, 255, 0.15);
    }
    
    .slot-time {
      font-weight: 600;
      font-size: 0.9rem;
      margin-bottom: 4px;
    }
    
    .slot-location {
      font-size: 0.75rem;
      color: #86868b;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    
    .slot-location-color {
      width: 8px;
      height: 8px;
      border-radius: 2px;
      flex-shrink: 0;
    }
  </style>
</head>
<body>
  <div class="booking-widget">
    <div class="chat-header">
      <div class="chat-title">Get Plump Booking</div>
      <div class="chat-subtitle">Book your appointment</div>
    </div>
    
    <div class="restart-button" onclick="restartChat()">Start Over</div>
    
    <div class="messages-container" id="messages"></div>
  </div>

  <script>
    // Debug logging
    console.log('Widget loading...');
    
    // Boulevard API Configuration - now using proxy route
    const BOULEVARD_CONFIG = {
      businessId: 'f6a06736-1132-4365-b79a-a69c648a746a',
      apiKey: '93ca3f15-6f0e-491d-840b-681a0fef80ed',
      apiUrl: '/api/blvd'  // Changed to use proxy route
    };
    
    const LOCATIONS_DATA = {
      'West Village': { 
        locationId: 'ffaaff3c-d5ba-408e-ba3b-455554b77116'
      },
      'SoHo': { 
        locationId: '89763e68-2454-429c-ae9c-c1b4d91e7b81'
      },
      'Tribeca': { 
        locationId: '43dfb866-a872-4f01-9491-6c6584e3c3e7'
      },
      'Williamsburg': { 
        locationId: '93566b17-c023-4fe1-9a84-462f143bd024'
      },
      'Hoboken': { 
        locationId: 'a885e859-21ef-43c7-8a63-bb242db98de2'
      },
      'Uptown': { 
        locationId: 'b146c47b-6de8-475a-8ebd-8a1d2b36546d'
      },
      'Miami': { 
        locationId: '1cbb848e-138b-4142-bc3d-b9f4ea9a42db'
      }
    };
    
    // Global state
    let conversationState = 'start';
    let treatmentType = null;
    let bookingFlow = null;
    let selectedLocation = null;
    let selectedLocationId = null;
    let selectedInjector = null;
    let selectedInjectorId = null;
    let selectedService = null;
    let selectedServiceId = null;
    let selectedTime = null;
    let cartId = null;
    let availableStaff = [];
    let availableServices = [];
    let availableTimes = [];
    let clientInfo = {};
    let currentCalendarDate = new Date();
    let calendarAvailability = {};
    let selectedDate = null;
    let injectorLocations = []; // For injector availability view
    let locationColors = {}; // Color mapping for locations
    let visibleLocations = new Set(); // Which locations are currently visible
    let injectorAvailabilityData = {}; // Availability data for injector view
    
    console.log('State initialized');
    
    // Utility functions
    function validateEmail(email) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      return emailRegex.test(email);
    }
    
    function validatePhoneNumber(phone) {
      const digitsOnly = phone.replace(/\D/g, '');
      return digitsOnly.length >= 10 && digitsOnly.length <= 15;
    }
    
    // Boulevard API helper - Updated to use proxy route
    function makeBoulevardRequest(query, variables = {}) {
  console.log('🔥 Making Boulevard request:', { 
    query: query.substring(0, 100) + '...', 
    variables 
  });
  
  return fetch(BOULEVARD_CONFIG.apiUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Accept': 'application/json'
    },
    body: JSON.stringify({
      query: query,
      variables: variables
    })
  })
  .then(response => {
    console.log('🔥 Boulevard response status:', response.status);
    
    // Handle different HTTP status codes
    if (response.status === 429) {
      throw new Error('Rate limit exceeded. Please wait a moment and try again.');
    }
    
    if (response.status === 500) {
      throw new Error('Server error. Please try again or contact support.');
    }
    
    if (response.status === 503) {
      throw new Error('Service temporarily unavailable. Please try again in a few minutes.');
    }
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
    
    return response.json();
  })
  .then(data => {
    console.log('🔥 Boulevard response data:', data);
    
    if (data.errors && data.errors.length > 0) {
      console.error('🔥 Boulevard GraphQL errors:', data.errors);
      
      // Handle specific GraphQL error types
      const error = data.errors[0];
      if (error.message.includes('permission') || error.message.includes('unauthorized')) {
        throw new Error('Authentication error. Please refresh the page and try again.');
      }
      
      if (error.message.includes('validation')) {
        throw new Error('Invalid request. Please check your information and try again.');
      }
      
      throw new Error(`API Error: ${error.message}`);
    }
    
    return data.data;
  })
  .catch(error => {
    console.error('🔥 Boulevard request failed:', error);
    
    // Handle network errors
    if (error.name === 'TypeError' && error.message.includes('fetch')) {
      throw new Error('Network error. Please check your connection and try again.');
    }
    
    // Re-throw the error to be handled by the calling function
    throw error;
  });
}
    // Debug function to check what fields BookingCompleteInput expects
    function debugBookingCompleteSchema() {
      console.log('🔍 Debugging BookingCompleteInput schema...');
      
      const introspectionQuery = `
        query {
          __type(name: "BookingCompleteInput") {
            name
            inputFields {
              name
              type {
                name
                kind
                ofType {
                  name
                  kind
                }
              }
              description
            }
          }
        }
      `;
      
      return makeBoulevardRequest(introspectionQuery)
        .then(data => {
          console.log('📋 BookingCompleteInput schema:', data.__type);
          if (data.__type && data.__type.inputFields) {
            console.log('📋 Required fields:');
            data.__type.inputFields.forEach(field => {
              console.log(`  - ${field.name}: ${field.type.name || field.type.kind}${field.type.ofType ? ' of ' + field.type.ofType.name : ''}`);
            });
          }
          return data.__type;
        })
        .catch(error => {
          console.error('Could not fetch schema:', error);
          return null;
        });
    }
    
    // Debug cart status before booking
    function debugCartStatus() {
      console.log('🔍 Debugging cart status before booking...');
      
      const query = `
        query GetCart($cartId: ID!) {
          cart(id: $cartId) {
            id
            state
            expiresAt
            clientInformation {
              firstName
              lastName
              email
              phoneNumber
            }
            selectedItems {
              id
              item {
                name
              }
              selectedStaffVariant {
                staff {
                  firstName
                  lastName
                }
              }
            }
            bookableTime {
              id
              startTime
            }
            errors {
              field
              message
            }
          }
        }
      `;
      
      return makeBoulevardRequest(query, { cartId: cartId })
        .then(data => {
          console.log('🔍 Cart debug info:', data.cart);
          return data.cart;
        })
        .catch(error => {
          console.error('🔍 Cart debug failed:', error);
          return null;
        });
    }
    
    // FIXED: Complete booking using Boulevard's bookingComplete mutation
    function completeAPIBooking() {
      console.log('✅ Completing booking using bookingComplete mutation...');
      
      const mutation = `
        mutation BookingComplete($input: BookingCompleteInput!) {
          bookingComplete(input: $input) {
            booking {
              id
              state
              insertedAt
            }
            bookingAppointments {
              id
              startTime
              endTime
              state
              client {
                id
                firstName
                lastName
                email
                phoneNumber
              }
              location {
                id
                name
              }
              services {
                id
                name
              }
              staff {
                id
                firstName
                lastName
              }
            }
            bookingWarnings {
              field
              message
            }
          }
        }
      `;
      
      // Try different input structures based on common Boulevard patterns
      const inputVariations = [
        // Variation 1: Just cart ID
        { cartId: cartId },
        // Variation 2: ID field instead of cartId
        { id: cartId },
        // Variation 3: With payment information (null for no payment)
        { 
          cartId: cartId,
          paymentMethodId: null,
          gratuityAmount: 0
        },
        // Variation 4: Complete structure
        {
          cartId: cartId,
          paymentMethod: null,
          gratuity: { amount: 0 },
          discountCodes: []
        }
      ];
      
      // Try each variation until one works
      function tryBookingComplete(variationIndex = 0) {
        if (variationIndex >= inputVariations.length) {
          throw new Error('All booking completion variations failed');
        }
        
        const input = inputVariations[variationIndex];
        console.log(`✅ Trying booking completion variation ${variationIndex + 1}:`, input);
        
        return makeBoulevardRequest(mutation, { input: input })
          .then(data => {
            console.log('✅ Booking completed successfully:', data);
            
            const result = data.bookingComplete;
            
            // Check for warnings
            if (result.bookingWarnings && result.bookingWarnings.length > 0) {
              console.warn('⚠️ Booking warnings:', result.bookingWarnings);
            }
            
            // Verify appointments were created
            if (result.bookingAppointments && result.bookingAppointments.length > 0) {
              const appointment = result.bookingAppointments[0];
              console.log('✅ Appointment created with ID:', appointment.id);
              console.log('✅ Appointment details:', appointment);
              
              return {
                success: true,
                bookingId: result.booking.id,
                appointmentId: appointment.id,
                appointment: appointment,
                warnings: result.bookingWarnings
              };
            } else {
              throw new Error('No appointments were created in the booking');
            }
          })
          .catch(error => {
            console.error(`❌ Booking variation ${variationIndex + 1} failed:`, error);
            
            // If this variation failed, try the next one
            if (variationIndex < inputVariations.length - 1) {
              console.log(`⏭️ Trying next variation...`);
              return tryBookingComplete(variationIndex + 1);
            } else {
              throw error;
            }
          });
      }
      
      return tryBookingComplete();
    }
    
    // Initialize
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOM loaded, starting conversation');
      startConversation();
    });
    
    function startConversation() {
      console.log('Starting conversation');
      const container = document.getElementById('messages');
      container.innerHTML = '';
      conversationState = 'start';
      
      // Reset state
      treatmentType = null;
      bookingFlow = null;
      selectedLocation = null;
      selectedLocationId = null;
      selectedInjector = null;
      selectedInjectorId = null;
      selectedService = null;
      selectedServiceId = null;
      selectedTime = null;
      cartId = null;
      availableStaff = [];
      availableServices = [];
      availableTimes = [];
      clientInfo = {};
      currentCalendarDate = new Date();
      calendarAvailability = {};
      selectedDate = null;
      injectorLocations = [];
      locationColors = {};
      visibleLocations = new Set();
      injectorAvailabilityData = {};
      
      addMessage('system', "Hi! Welcome to Plump. I'll help you book your appointment.", function() {
        addMessage('system', "What type of treatment are you interested in?", function() {
          showTreatmentTypeSelection();
        });
      });
    }
    
    function addMessage(type, text, callback) {
      const container = document.getElementById('messages');
      
      if (type === 'system') {
        showTyping(function() {
          const message = document.createElement('div');
          message.className = 'message ' + type;
          
          const bubble = document.createElement('div');
          bubble.className = 'message-bubble';
          bubble.innerHTML = text;
          
          message.appendChild(bubble);
          container.appendChild(message);
          scrollToBottom();
          
          if (callback) {
            setTimeout(callback, 500);
          }
        });
      } else {
        const message = document.createElement('div');
        message.className = 'message ' + type;
        
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble';
        bubble.textContent = text;
        
        message.appendChild(bubble);
        container.appendChild(message);
        scrollToBottom();
        
        if (callback) {
          setTimeout(callback, 300);
        }
      }
    }
    
    function showTyping(callback) {
      const container = document.getElementById('messages');
      const typingMessage = document.createElement('div');
      typingMessage.className = 'message system';
      typingMessage.id = 'typing-indicator';
      
      const typingIndicator = document.createElement('div');
      typingIndicator.className = 'typing-indicator';
      
      const typingDots = document.createElement('div');
      typingDots.className = 'typing-dots';
      
      for (let i = 0; i < 3; i++) {
        const dot = document.createElement('div');
        dot.className = 'dot';
        typingDots.appendChild(dot);
      }
      
      typingIndicator.appendChild(typingDots);
      typingMessage.appendChild(typingIndicator);
      container.appendChild(typingMessage);
      scrollToBottom();
      
      setTimeout(function() {
        const indicator = document.getElementById('typing-indicator');
        if (indicator) {
          indicator.remove();
        }
        callback();
      }, 1200);
    }
    
    function showTreatmentTypeSelection() {
      console.log('Showing treatment type selection');
      const container = document.getElementById('messages');
      const treatmentMessage = document.createElement('div');
      treatmentMessage.className = 'message system';
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      
      const grid = document.createElement('div');
      grid.className = 'treatment-grid';
      grid.style.gridTemplateColumns = '1fr'; // Stack vertically for 3 options
      
      // Injectable button
      const injectableButton = document.createElement('button');
      injectableButton.className = 'treatment-button';
      injectableButton.onclick = () => selectTreatmentType('injectable');
      
      const injectableTitle = document.createElement('div');
      injectableTitle.className = 'treatment-title';
      injectableTitle.textContent = 'Injectable Treatments';
      
      const injectableDesc = document.createElement('div');
      injectableDesc.className = 'treatment-desc';
      injectableDesc.textContent = 'Botox, fillers, and other injectable services';
      
      injectableButton.appendChild(injectableTitle);
      injectableButton.appendChild(injectableDesc);
      
      // Skin treatments button
      const skinButton = document.createElement('button');
      skinButton.className = 'treatment-button';
      skinButton.onclick = () => selectTreatmentType('skin');
      
      const skinTitle = document.createElement('div');
      skinTitle.className = 'treatment-title';
      skinTitle.textContent = 'Skin Treatments';
      
      const skinDesc = document.createElement('div');
      skinDesc.className = 'treatment-desc';
      skinDesc.textContent = 'Laser, microneedling, and skincare services';
      
      skinButton.appendChild(skinTitle);
      skinButton.appendChild(skinDesc);
      
      // Injector availability button
      const injectorAvailButton = document.createElement('button');
      injectorAvailButton.className = 'treatment-button';
      injectorAvailButton.onclick = () => selectTreatmentType('injector-availability');
      
      const injectorAvailTitle = document.createElement('div');
      injectorAvailTitle.className = 'treatment-title';
      injectorAvailTitle.textContent = 'See a Specific Injector\'s Availability';
      
      const injectorAvailDesc = document.createElement('div');
      injectorAvailDesc.className = 'treatment-desc';
      injectorAvailDesc.textContent = 'View open slots for your preferred injector across all locations';
      
      injectorAvailButton.appendChild(injectorAvailTitle);
      injectorAvailButton.appendChild(injectorAvailDesc);
      
      grid.appendChild(injectableButton);
      grid.appendChild(skinButton);
      grid.appendChild(injectorAvailButton);
      
      bubble.appendChild(grid);
      treatmentMessage.appendChild(bubble);
      container.appendChild(treatmentMessage);
      scrollToBottom();
    }
    
    function selectTreatmentType(type) {
  treatmentType = type;
  
  if (type === 'injectable') {
    addMessage('user', 'Injectable Treatments');
    addMessage('system', 'Great! First, what type of client are you?', function() {
      showClientSelection();
    });
  } else if (type === 'skin') {
    addMessage('user', 'Skin Treatments');
    addMessage('system', 'Perfect! First, what type of client are you?', function() {
      showClientSelection();
    });
  } else if (type === 'injector-availability') {
    addMessage('user', 'See a Specific Injector\'s Availability');
    addMessage('system', 'Perfect! Let me load our team of injectors and their availability...', function() {
      loadInjectorsForAvailability();
    });
  }
}
    
    function showInjectableBookingFlow() {
      const container = document.getElementById('messages');
      const flowMessage = document.createElement('div');
      flowMessage.className = 'message system';
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      
      const grid = document.createElement('div');
      grid.className = 'treatment-grid';
      
      // Book by injector
      const injectorButton = document.createElement('button');
      injectorButton.className = 'treatment-button';
      injectorButton.onclick = () => selectBookingFlow('by-injector');
      
      const injectorTitle = document.createElement('div');
      injectorTitle.className = 'treatment-title';
      injectorTitle.textContent = 'Book by Injector';
      
      const injectorDesc = document.createElement('div');
      injectorDesc.className = 'treatment-desc';
      injectorDesc.textContent = 'Choose your preferred injector first';
      
      injectorButton.appendChild(injectorTitle);
      injectorButton.appendChild(injectorDesc);
      
      // Book by location
      const locationButton = document.createElement('button');
      locationButton.className = 'treatment-button';
      locationButton.onclick = () => selectBookingFlow('by-location');
      
      const locationTitle = document.createElement('div');
      locationTitle.className = 'treatment-title';
      locationTitle.textContent = 'Book by Location';
      
      const locationDesc = document.createElement('div');
      locationDesc.className = 'treatment-desc';
      locationDesc.textContent = 'Choose your preferred location first';
      
      locationButton.appendChild(locationTitle);
      locationButton.appendChild(locationDesc);
      
      grid.appendChild(injectorButton);
      grid.appendChild(locationButton);
      
      bubble.appendChild(grid);
      flowMessage.appendChild(bubble);
      container.appendChild(flowMessage);
      scrollToBottom();
    }
    
    function selectBookingFlow(flow) {
      bookingFlow = flow;
      addMessage('user', flow === 'by-injector' ? 'Book by Injector' : 'Book by Location');
      
      if (flow === 'by-injector') {
        addMessage('system', 'Let me show you our available injectors...', function() {
          loadInjectors();
        });
      } else {
        addMessage('system', 'Please select your preferred location:', function() {
          showLocationSelection();
        });
      }
    }
    
    function loadInjectors() {
      console.log('🔍 Loading injectors from Boulevard API...');
      
      // Show loading state
      addMessage('system', 'Loading our team of injectors...');
      
      // Check all locations to get complete staff list
      const locationEntries = Object.entries(LOCATIONS_DATA);
      
      console.log('🔍 Checking locations:', locationEntries.map(([name, data]) => name));
      
      // We'll aggregate staff from all locations and track which locations they work at
      const allStaffPromises = locationEntries.map(([locationName, locationData]) => {
        const locationId = locationData.locationId.indexOf('urn:blvd:Location:') === 0 ? 
          locationData.locationId : 'urn:blvd:Location:' + locationData.locationId;
        
        console.log('🔍 Creating cart for location:', locationName, locationId);
        
        const query = `
          mutation CreateTempCart($locationId: ID!) {
            createCart(input: { locationId: $locationId }) {
              cart {
                id
                availableCategories {
                  name
                  availableItems {
                    id
                    name
                    ... on CartAvailableBookableItem {
                      staffVariants {
                        id
                        staff {
                          id
                          firstName
                          lastName
                          nickname
                          avatar
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        `;
        
        return makeBoulevardRequest(query, { locationId: locationId })
          .then(data => {
            console.log('🔍 Response from location:', locationName, data);
            return {
              locationName: locationName,
              locationId: locationId,
              cart: data.createCart.cart
            };
          })
          .catch(error => {
            console.error('🔍 Failed to load from location:', locationName, error);
            return {
              locationName: locationName,
              locationId: locationId,
              cart: null,
              error: error.message
            };
          });
      });
      
      Promise.all(allStaffPromises)
        .then(responses => {
          console.log('🔍 All cart responses received:', responses);
          
          const staffMap = new Map();
          let totalItemsChecked = 0;
          let totalStaffVariantsFound = 0;
          let locationsWithErrors = [];
          
          responses.forEach(response => {
            if (!response || !response.cart) {
              if (response && response.error) {
                locationsWithErrors.push(`${response.locationName}: ${response.error}`);
              }
              return;
            }
            
            const { locationName, cart } = response;
            console.log(`🔍 Processing cart for ${locationName}:`, cart);
            
            if (cart.availableCategories) {
              cart.availableCategories.forEach(category => {
                console.log(`🔍 Processing category: ${category.name}`);
                if (category.availableItems) {
                  category.availableItems.forEach(item => {
                    totalItemsChecked++;
                    console.log(`🔍 Processing item: ${item.name}`, item.staffVariants);
                    
                    if (item.staffVariants && item.staffVariants.length > 0) {
                      totalStaffVariantsFound += item.staffVariants.length;
                      item.staffVariants.forEach(variant => {
                        if (variant.staff) {
                          console.log(`🔍 Processing staff variant:`, variant.staff);
                          if (!staffMap.has(variant.staff.id)) {
                            staffMap.set(variant.staff.id, {
                              id: variant.staff.id,
                              firstName: variant.staff.firstName,
                              lastName: variant.staff.lastName,
                              nickname: variant.staff.nickname,
                              avatar: variant.staff.avatar ? { url: variant.staff.avatar } : null,
                              role: { name: 'Provider' },
                              locations: [locationName] // Track locations
                            });
                          } else {
                            // Add this location to the staff member's locations
                            const staff = staffMap.get(variant.staff.id);
                            if (!staff.locations.includes(locationName)) {
                              staff.locations.push(locationName);
                            }
                          }
                        }
                      });
                    }
                  });
                }
              });
            }
          });
          
          if (locationsWithErrors.length > 0) {
            console.log('🔍 Locations with errors:', locationsWithErrors);
          }
          
          console.log(`🔍 Summary: ${totalItemsChecked} items checked across all locations, ${totalStaffVariantsFound} staff variants found`);
          
          const staffList = Array.from(staffMap.values());
          console.log('🔍 Final staff list with locations:', staffList);
          
          if (staffList.length > 0) {
            console.log('✅ Successfully loaded staff from Boulevard:', staffList);
            console.log('✅ Staff and their locations:', staffList.map(s => 
              `${s.firstName} ${s.lastName}: ${s.locations.join(', ')}`
            ));
            availableStaff = staffList;
            
            // Force refresh the injector display
            console.log('🔄 Refreshing injector display...');
            showInjectors();
          } else {
            console.log('❌ No staff found in Boulevard API, using enhanced mock data');
            loadEnhancedMockStaff();
          }
        })
        .catch(error => {
          console.error('❌ Failed to load staff from all locations:', error);
          console.log('❌ Falling back to enhanced mock staff data');
          loadEnhancedMockStaff();
        });
    }
    
    function loadEnhancedMockStaff() {
      console.log('Using enhanced mock staff data with more comprehensive team');
      
      const mockStaff = [
        {
          id: 'staff1',
          firstName: 'Sarah',
          lastName: 'Johnson',
          role: { name: 'Senior Injector' },
          avatar: null,
          locations: ['West Village', 'SoHo']
        },
        {
          id: 'staff2',
          firstName: 'Michael',
          lastName: 'Chen',
          role: { name: 'Lead Aesthetician' },
          avatar: null,
          locations: ['Tribeca', 'Williamsburg']
        },
        {
          id: 'staff3',
          firstName: 'Emily',
          lastName: 'Rodriguez',
          role: { name: 'Injector' },
          avatar: null,
          locations: ['Hoboken', 'Uptown']
        },
        {
          id: 'staff4',
          firstName: 'David',
          lastName: 'Thompson',
          role: { name: 'Medical Director' },
          avatar: null,
          locations: ['Miami', 'West Village']
        },
        {
          id: 'staff5',
          firstName: 'Jessica',
          lastName: 'Martinez',
          role: { name: 'Senior Injector' },
          avatar: null,
          locations: ['SoHo', 'Tribeca']
        },
        {
          id: 'staff6',
          firstName: 'Alex',
          lastName: 'Kim',
          role: { name: 'Aesthetic Nurse' },
          avatar: null,
          locations: ['Williamsburg', 'Hoboken']
        },
        {
          id: 'staff7',
          firstName: 'Rachel',
          lastName: 'Davis',
          role: { name: 'Injector' },
          avatar: null,
          locations: ['Uptown', 'Miami']
        },
        {
          id: 'staff8',
          firstName: 'Marcus',
          lastName: 'Wilson',
          role: { name: 'Lead Injector' },
          avatar: null,
          locations: ['West Village', 'Tribeca', 'SoHo']
        },
        {
          id: 'staff9',
          firstName: 'Lisa',
          lastName: 'Brown',
          role: { name: 'Aesthetic Specialist' },
          avatar: null,
          locations: ['Williamsburg', 'Uptown']
        },
        {
          id: 'staff10',
          firstName: 'James',
          lastName: 'Garcia',
          role: { name: 'Senior Aesthetician' },
          avatar: null,
          locations: ['Hoboken', 'Miami']
        }
      ];
      
      availableStaff = mockStaff;
      console.log('✅ Enhanced mock staff loaded:', mockStaff.length, 'team members');
      showInjectors();
    }
    
    function showInjectors() {
      console.log('🎨 Showing injectors with pill layout');
      
      const container = document.getElementById('messages');
      const injectorsMessage = document.createElement('div');
      injectorsMessage.className = 'message system';
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      
      const injectorContainer = document.createElement('div');
      injectorContainer.className = 'injector-container';
      
      const injectorList = document.createElement('div');
      injectorList.className = 'injector-list';
      
      // First Available option
      const firstAvailableItem = document.createElement('div');
      firstAvailableItem.className = 'injector-item first-available';
      firstAvailableItem.onclick = () => selectInjector('first-available', 'First Available');
      
      const firstAvailablePhoto = document.createElement('div');
      firstAvailablePhoto.className = 'injector-photo';
      
      const firstAvailableName = document.createElement('div');
      firstAvailableName.className = 'injector-name';
      firstAvailableName.textContent = 'First Available';
      
      firstAvailableItem.appendChild(firstAvailablePhoto);
      firstAvailableItem.appendChild(firstAvailableName);
      
      injectorList.appendChild(firstAvailableItem);
      
      // Individual injectors
      availableStaff.forEach((staff, index) => {
        console.log(`🎨 Creating pill for staff ${index + 1}:`, staff);
        
        const item = document.createElement('div');
        item.className = 'injector-item';
        item.onclick = () => selectInjector(staff.id, staff.firstName + ' ' + staff.lastName);
        
        const photo = document.createElement('div');
        photo.className = 'injector-photo';
        if (staff.avatar && staff.avatar.url) {
          photo.style.backgroundImage = `url(${staff.avatar.url})`;
        }
        
        const name = document.createElement('div');
        name.className = 'injector-name';
        name.textContent = staff.firstName + ' ' + staff.lastName;
        
        item.appendChild(photo);
        item.appendChild(name);
        
        injectorList.appendChild(item);
      });
      
      injectorContainer.appendChild(injectorList);
      bubble.appendChild(injectorContainer);
      
      const smsButton = document.createElement('button');
      smsButton.className = 'secondary-button';
      smsButton.textContent = "Don't see your preferred injector? Contact us";
      smsButton.onclick = () => openSMS('injector-inquiry');
      bubble.appendChild(smsButton);
      
      injectorsMessage.appendChild(bubble);
      container.appendChild(injectorsMessage);
      scrollToBottom();
      
      console.log('🎨 Injector pill display complete');
    }
    
    // NEW: Load injectors specifically for availability view
    function loadInjectorsForAvailability() {
      console.log('🔍 Loading injectors for availability view...');
      
      // Show loading state
      const container = document.getElementById('messages');
      const loadingMessage = document.createElement('div');
      loadingMessage.className = 'message system';
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      bubble.textContent = 'Loading our team of injectors...';
      
      loadingMessage.appendChild(bubble);
      container.appendChild(loadingMessage);
      scrollToBottom();
      
      // Get all locations and their staff
      const locationEntries = Object.entries(LOCATIONS_DATA);
      console.log('🔍 Loading staff from all locations for availability view');
      
      const allStaffPromises = locationEntries.map(([locationName, locationData]) => {
        const locationId = locationData.locationId.indexOf('urn:blvd:Location:') === 0 ? 
          locationData.locationId : 'urn:blvd:Location:' + locationData.locationId;
        
        const query = `
          mutation CreateTempCart($locationId: ID!) {
            createCart(input: { locationId: $locationId }) {
              cart {
                id
                availableCategories {
                  name
                  availableItems {
                    id
                    name
                    ... on CartAvailableBookableItem {
                      staffVariants {
                        id
                        staff {
                          id
                          firstName
                          lastName
                          nickname
                          avatar
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        `;
        
        return makeBoulevardRequest(query, { locationId: locationId })
          .then(data => ({
            locationName: locationName,
            locationId: locationId,
            cart: data.createCart.cart
          }))
          .catch(error => {
            console.error('🔍 Failed to load from location:', locationName, error);
            return { locationName: locationName, locationId: locationId, cart: null };
          });
      });
      
      Promise.all(allStaffPromises)
        .then(responses => {
          const staffMap = new Map();
          
          responses.forEach(response => {
            if (!response.cart) return;
            
            const { locationName, cart } = response;
            
            if (cart.availableCategories) {
              cart.availableCategories.forEach(category => {
                if (category.availableItems) {
                  category.availableItems.forEach(item => {
                    if (item.staffVariants && item.staffVariants.length > 0) {
                      item.staffVariants.forEach(variant => {
                        if (variant.staff) {
                          if (!staffMap.has(variant.staff.id)) {
                            staffMap.set(variant.staff.id, {
                              id: variant.staff.id,
                              firstName: variant.staff.firstName,
                              lastName: variant.staff.lastName,
                              nickname: variant.staff.nickname,
                              avatar: variant.staff.avatar ? { url: variant.staff.avatar } : null,
                              locations: [locationName]
                            });
                          } else {
                            const staff = staffMap.get(variant.staff.id);
                            if (!staff.locations.includes(locationName)) {
                              staff.locations.push(locationName);
                            }
                          }
                        }
                      });
                    }
                  });
                }
              });
            }
          });
          
          const staffList = Array.from(staffMap.values());
          
          if (staffList.length > 0) {
            console.log('✅ Successfully loaded staff for availability view:', staffList);
            availableStaff = staffList;
            assignLocationColors(staffList);
            showInjectorsForAvailability();
          } else {
            console.log('❌ No staff found, using mock data');
            loadMockStaffForAvailability();
          }
        })
        .catch(error => {
          console.error('❌ Failed to load staff:', error);
          loadMockStaffForAvailability();
        });
    }
    
    function loadMockStaffForAvailability() {
      const mockStaff = [
        {
          id: 'staff1',
          firstName: 'Sarah',
          lastName: 'Johnson',
          avatar: null,
          locations: ['West Village', 'SoHo']
        },
        {
          id: 'staff2',
          firstName: 'Michael',
          lastName: 'Chen',
          avatar: null,
          locations: ['Tribeca', 'Williamsburg']
        },
        {
          id: 'staff3',
          firstName: 'Emily',
          lastName: 'Rodriguez',
          avatar: null,
          locations: ['Hoboken', 'Uptown']
        },
        {
          id: 'staff4',
          firstName: 'David',
          lastName: 'Thompson',
          avatar: null,
          locations: ['Miami', 'West Village']
        },
        {
          id: 'staff5',
          firstName: 'Jessica',
          lastName: 'Martinez',
          avatar: null,
          locations: ['SoHo', 'Tribeca']
        }
      ];
      
      availableStaff = mockStaff;
      assignLocationColors(mockStaff);
      showInjectorsForAvailability();
    }
    
    function assignLocationColors(staffList) {
      const colors = ['#007AFF', '#34C759', '#FF9500', '#FF3B30', '#5856D6', '#AF52DE', '#FF2D92', '#64D2FF'];
      const allLocations = new Set();
      
      staffList.forEach(staff => {
        staff.locations.forEach(location => allLocations.add(location));
      });
      
      const locationArray = Array.from(allLocations);
      locationColors = {};
      
      locationArray.forEach((location, index) => {
        locationColors[location] = colors[index % colors.length];
      });
      
      console.log('🎨 Assigned location colors:', locationColors);
    }
    
    function showInjectorsForAvailability() {
      console.log('🎨 Showing injectors for availability view');
      
      // Remove loading message
      const messages = document.querySelectorAll('.message');
      const lastMessage = messages[messages.length - 1];
      if (lastMessage && lastMessage.textContent.includes('Loading our team')) {
        lastMessage.remove();
      }
      
      const container = document.getElementById('messages');
      const injectorsMessage = document.createElement('div');
      injectorsMessage.className = 'message system';
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      bubble.innerHTML = 'Select an injector to view their availability across all locations:';
      
      const injectorContainer = document.createElement('div');
      injectorContainer.className = 'injector-container';
      
      const injectorList = document.createElement('div');
      injectorList.className = 'injector-list';
      
      // Show individual injectors
      availableStaff.forEach((staff, index) => {
        const item = document.createElement('div');
        item.className = 'injector-item';
        item.onclick = () => selectInjectorForAvailability(staff);
        
        const photo = document.createElement('div');
        photo.className = 'injector-photo';
        if (staff.avatar && staff.avatar.url) {
          photo.style.backgroundImage = `url(${staff.avatar.url})`;
        }
        
        const name = document.createElement('div');
        name.className = 'injector-name';
        name.textContent = `${staff.firstName} ${staff.lastName}`;
        
        // Add location info
        const locations = document.createElement('div');
        locations.style.fontSize = '0.8rem';
        locations.style.color = '#86868b';
        locations.style.marginTop = '4px';
        locations.textContent = staff.locations.join(', ');
        
        const info = document.createElement('div');
        info.style.flex = '1';
        info.appendChild(name);
        info.appendChild(locations);
        
        item.appendChild(photo);
        item.appendChild(info);
        
        injectorList.appendChild(item);
      });
      
      injectorContainer.appendChild(injectorList);
      bubble.appendChild(injectorContainer);
      
      injectorsMessage.appendChild(bubble);
      container.appendChild(injectorsMessage);
      scrollToBottom();
    }
    
    function selectInjectorForAvailability(staff) {
      selectedInjector = `${staff.firstName} ${staff.lastName}`;
      selectedInjectorId = staff.id;
      injectorLocations = staff.locations;
      
      // Initialize all locations as visible
      visibleLocations = new Set(staff.locations);
      
      addMessage('user', selectedInjector);
      addMessage('system', `Perfect! Loading ${selectedInjector}'s availability across all locations...`, function() {
        loadInjectorAvailabilityAcrossLocations();
      });
    }
    
    function loadInjectorAvailabilityAcrossLocations() {
      console.log('🔍 Loading availability for injector across all locations');
      
      const promises = injectorLocations.map(locationName => {
        return loadInjectorAvailabilityForLocation(locationName);
      });
      
      Promise.all(promises)
        .then(() => {
          console.log('✅ Loaded availability for all locations');
          showInjectorAvailabilityCalendar();
        })
        .catch(error => {
          console.error('❌ Failed to load availability:', error);
          showErrorMessage('Unable to load availability. Please try again or contact us.');
        });
    }
    
    function loadInjectorAvailabilityForLocation(locationName) {
      const locationData = LOCATIONS_DATA[locationName];
      if (!locationData) {
        console.error('Location not found:', locationName);
        return Promise.resolve();
      }
      
      const locationId = locationData.locationId.indexOf('urn:blvd:Location:') === 0 ? 
        locationData.locationId : 'urn:blvd:Location:' + locationData.locationId;
      
      console.log(`🔍 Loading availability for ${locationName}`);
      
      // Create a temporary cart for this location
      const createCartQuery = `
        mutation CreateTempCart($locationId: ID!) {
          createCart(input: { locationId: $locationId }) {
            cart {
              id
              availableCategories {
                availableItems {
                  id
                  name
                  ... on CartAvailableBookableItem {
                    staffVariants {
                      id
                      staff {
                        id
                        firstName
                        lastName
                      }
                    }
                  }
                }
              }
            }
          }
        }
      `;
      
      return makeBoulevardRequest(createCartQuery, { locationId: locationId })
        .then(data => {
          const cart = data.createCart.cart;
          
          // Find a service that this injector can perform
          let selectedServiceId = null;
          let selectedStaffVariantId = null;
          
          for (const category of cart.availableCategories) {
            for (const item of category.availableItems) {
              if (item.staffVariants) {
                const staffVariant = item.staffVariants.find(variant => 
                  variant.staff && variant.staff.id === selectedInjectorId
                );
                if (staffVariant) {
                  selectedServiceId = item.id;
                  selectedStaffVariantId = staffVariant.id;
                  break;
                }
              }
            }
            if (selectedServiceId) break;
          }
          
          if (!selectedServiceId) {
            console.log(`No services found for injector at ${locationName}`);
            return;
          }
          
          // Add service to cart
          const addServiceQuery = `
            mutation AddCartItem($cartId: ID!, $itemId: ID!, $itemStaffVariantId: ID!) {
              addCartSelectedBookableItem(input: {
                id: $cartId,
                itemId: $itemId,
                itemStaffVariantId: $itemStaffVariantId
              }) {
                cart {
                  id
                }
              }
            }
          `;
          
          return makeBoulevardRequest(addServiceQuery, {
            cartId: cart.id,
            itemId: selectedServiceId,
            itemStaffVariantId: selectedStaffVariantId
          }).then(() => {
            // Load availability for the next 30 days
            const promises = [];
            const today = new Date();
            
            for (let i = 0; i < 30; i++) {
              const date = new Date(today);
              date.setDate(date.getDate() + i);
              promises.push(loadAvailabilityForInjectorDate(cart.id, date, locationName));
            }
            
            return Promise.all(promises);
          });
        })
        .catch(error => {
          console.error(`Failed to load availability for ${locationName}:`, error);
        });
    }
    
    function loadAvailabilityForInjectorDate(cartId, date, locationName) {
      const dateStr = date.toISOString().split('T')[0];
      
      const query = `
        query GetCartBookableTimes($cartId: ID!, $searchDate: Date!) {
          cartBookableTimes(
            id: $cartId,
            searchDate: $searchDate,
            tz: "America/New_York"
          ) {
            id
            startTime
          }
        }
      `;
      
      return makeBoulevardRequest(query, { 
        cartId: cartId, 
        searchDate: dateStr 
      })
        .then(data => {
          const times = data.cartBookableTimes || [];
          
          if (!injectorAvailabilityData[dateStr]) {
            injectorAvailabilityData[dateStr] = {};
          }
          
          injectorAvailabilityData[dateStr][locationName] = times;
          return times;
        })
        .catch(error => {
          console.error('Failed to load availability for', dateStr, locationName, error);
          if (!injectorAvailabilityData[dateStr]) {
            injectorAvailabilityData[dateStr] = {};
          }
          injectorAvailabilityData[dateStr][locationName] = [];
          return [];
        });
    }
    
    function showInjectorAvailabilityCalendar() {
      const container = document.getElementById('messages');
      const calendarMessage = document.createElement('div');
      calendarMessage.className = 'message system';
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      
      // Location legend and toggle
      const legend = document.createElement('div');
      legend.className = 'location-legend';
      
      const legendTitle = document.createElement('div');
      legendTitle.className = 'legend-title';
      legendTitle.textContent = 'Locations (click to toggle):';
      
      const legendItems = document.createElement('div');
      legendItems.className = 'legend-items';
      
      injectorLocations.forEach(locationName => {
        const legendItem = document.createElement('div');
        legendItem.className = 'legend-item';
        if (!visibleLocations.has(locationName)) {
          legendItem.classList.add('inactive');
        }
        
        legendItem.onclick = () => toggleLocationVisibility(locationName);
        
        const colorDiv = document.createElement('div');
        colorDiv.className = 'legend-color';
        colorDiv.style.backgroundColor = locationColors[locationName];
        
        const nameDiv = document.createElement('div');
        nameDiv.textContent = locationName;
        
        legendItem.appendChild(colorDiv);
        legendItem.appendChild(nameDiv);
        legendItems.appendChild(legendItem);
      });
      
      legend.appendChild(legendTitle);
      legend.appendChild(legendItems);
      
      // Calendar container
      const availabilityContainer = document.createElement('div');
      availabilityContainer.className = 'availability-container';
      availabilityContainer.id = 'injector-availability-container';
      
      bubble.appendChild(legend);
      bubble.appendChild(availabilityContainer);
      
      calendarMessage.appendChild(bubble);
      container.appendChild(calendarMessage);
      scrollToBottom();
      
      renderInjectorAvailabilityCalendar();
    }
    
    function toggleLocationVisibility(locationName) {
      if (visibleLocations.has(locationName)) {
        visibleLocations.delete(locationName);
      } else {
        visibleLocations.add(locationName);
      }
      
      // Update legend items
      const legendItems = document.querySelectorAll('.legend-item');
      legendItems.forEach(item => {
        const locationText = item.textContent;
        if (locationText === locationName) {
          if (visibleLocations.has(locationName)) {
            item.classList.remove('inactive');
          } else {
            item.classList.add('inactive');
          }
        }
      });
      
      // Re-render calendar
      renderInjectorAvailabilityCalendar();
    }
    
    function renderInjectorAvailabilityCalendar() {
      const container = document.getElementById('injector-availability-container');
      container.innerHTML = '';
      
   // Calendar header
const calendarHeader = document.createElement('div');
calendarHeader.className = 'calendar-header';

const prevButton = document.createElement('button');
prevButton.className = 'calendar-nav';
prevButton.textContent = '← Previous';
prevButton.onclick = () => navigateInjectorMonth(-1);

const calendarTitle = document.createElement('div');
calendarTitle.className = 'calendar-title';
const displayDate = currentCalendarDate || new Date();
calendarTitle.textContent = `${selectedInjector}'s Availability - ${displayDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}`;

const nextButton = document.createElement('button');
nextButton.className = 'calendar-nav';
nextButton.textContent = 'Next →';
nextButton.onclick = () => navigateInjectorMonth(1);

calendarHeader.appendChild(prevButton);
calendarHeader.appendChild(calendarTitle);
calendarHeader.appendChild(nextButton);
      
      // Calendar grid
      const calendarGrid = document.createElement('div');
      calendarGrid.className = 'calendar-grid';
      
      // Day headers
      const dayHeaders = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      dayHeaders.forEach(day => {
        const dayHeader = document.createElement('div');
        dayHeader.className = 'calendar-day-header';
        dayHeader.textContent = day;
        calendarGrid.appendChild(dayHeader);
      });
      
      // Generate calendar for current month
      const today = new Date();
      const year = today.getFullYear();
      const month = today.getMonth();
      const firstDay = new Date(year, month, 1);
      const lastDay = new Date(year, month + 1, 0);
      
      // Add empty cells for days before the first day of the month
      for (let i = 0; i < firstDay.getDay(); i++) {
        const emptyDay = document.createElement('div');
        emptyDay.className = 'calendar-day disabled';
        calendarGrid.appendChild(emptyDay);
      }
      
      // Add days of the month
      for (let day = 1; day <= lastDay.getDate(); day++) {
        const date = new Date(year, month, day);
        const dateStr = date.toISOString().split('T')[0];
        const dayElement = document.createElement('div');
        dayElement.className = 'calendar-day injector-calendar-day';
        
        // Check if day is in the past
        if (date < today) {
          dayElement.classList.add('disabled');
        } else {
          dayElement.onclick = () => selectInjectorDate(date);
        }
        
        const dayNumber = document.createElement('div');
        dayNumber.className = 'day-number';
        dayNumber.textContent = day;
        
        const slotsContainer = document.createElement('div');
        slotsContainer.className = 'calendar-slots';
        
        // Add slot indicators for visible locations
        const dayData = injectorAvailabilityData[dateStr];
        if (dayData) {
          let hasSlots = false;
          
          Object.keys(dayData).forEach(locationName => {
            if (!visibleLocations.has(locationName)) return;
            
            const slots = dayData[locationName];
            if (slots && slots.length > 0) {
              hasSlots = true;
              
              // Show up to 3 slot indicators per location
              const slotsToShow = Math.min(3, slots.length);
              for (let i = 0; i < slotsToShow; i++) {
                const slotIndicator = document.createElement('div');
                slotIndicator.className = 'slot-indicator';
                slotIndicator.style.backgroundColor = locationColors[locationName];
                slotIndicator.title = `${locationName} - ${slots.length} slot${slots.length > 1 ? 's' : ''}`;
                slotsContainer.appendChild(slotIndicator);
              }
            }
          });
          
          if (hasSlots) {
            dayElement.classList.add('has-availability');
          }
        }
        
        dayElement.appendChild(dayNumber);
        dayElement.appendChild(slotsContainer);
        calendarGrid.appendChild(dayElement);
      }
      
      container.appendChild(calendarHeader);
      container.appendChild(calendarGrid);
      
      // Time slots container (initially hidden)
      const timeSlotsContainer = document.createElement('div');
      timeSlotsContainer.className = 'injector-time-slots';
      timeSlotsContainer.id = 'injector-time-slots-container';
      timeSlotsContainer.style.display = 'none';
      container.appendChild(timeSlotsContainer);
    }

    function navigateInjectorMonth(direction) {
  if (!currentCalendarDate) {
    currentCalendarDate = new Date();
  }
  currentCalendarDate.setMonth(currentCalendarDate.getMonth() + direction);
  
  // Clear existing availability data
  injectorAvailabilityData = {};
  
  // Show loading message
  const container = document.getElementById('injector-availability-container');
  container.innerHTML = '<div style="text-align: center; padding: 20px; color: #86868b;">Loading availability...</div>';
  
  // Reload availability for new month
  loadInjectorAvailabilityAcrossLocations();
}
    
    function selectInjectorDate(date) {
      selectedDate = date;
      const dateStr = date.toISOString().split('T')[0];
      
      // Update selected state in calendar
      document.querySelectorAll('.injector-calendar-day').forEach(day => {
        day.classList.remove('selected');
      });
      
      // Find and select the clicked day
      const dayElements = document.querySelectorAll('.injector-calendar-day');
      dayElements.forEach(dayElement => {
        const dayNumber = dayElement.querySelector('.day-number');
        if (dayNumber && parseInt(dayNumber.textContent) === date.getDate()) {
          dayElement.classList.add('selected');
        }
      });
      
      showInjectorTimeSlotsForDate(date);
    }
    
    function showInjectorTimeSlotsForDate(date) {
      const dateStr = date.toISOString().split('T')[0];
      const dayData = injectorAvailabilityData[dateStr];
      
      const timeSlotsContainer = document.getElementById('injector-time-slots-container');
      timeSlotsContainer.innerHTML = '';
      
      if (!dayData) {
        timeSlotsContainer.innerHTML = '<p style="text-align: center; color: #86868b; padding: 20px;">No availability data for this date</p>';
        timeSlotsContainer.style.display = 'block';
        return;
      }
      
      const allSlots = [];
      
      // Collect all slots from visible locations
      Object.keys(dayData).forEach(locationName => {
        if (!visibleLocations.has(locationName)) return;
        
        const slots = dayData[locationName] || [];
        slots.forEach(slot => {
          allSlots.push({
            ...slot,
            locationName: locationName,
            color: locationColors[locationName]
          });
        });
      });
      
      if (allSlots.length === 0) {
        timeSlotsContainer.innerHTML = '<p style="text-align: center; color: #86868b; padding: 20px;">No available times for this date</p>';
      } else {
        // Sort slots by time
        allSlots.sort((a, b) => new Date(a.startTime) - new Date(b.startTime));
        
        allSlots.forEach(slot => {
          const startTime = new Date(slot.startTime);
          const timeStr = startTime.toLocaleTimeString('en-US', {
            hour: 'numeric',
            minute: '2-digit',
            hour12: true
          });
          
          const timeSlot = document.createElement('div');
          timeSlot.className = 'injector-time-slot';
          timeSlot.onclick = () => selectInjectorTimeSlot(slot, timeStr, date.toLocaleDateString('en-US', {
            weekday: 'short',
            month: 'short',
            day: 'numeric'
          }));
          
          const timeDiv = document.createElement('div');
          timeDiv.className = 'slot-time';
          timeDiv.textContent = timeStr;
          
          const locationDiv = document.createElement('div');
          locationDiv.className = 'slot-location';
          
          const colorDiv = document.createElement('div');
          colorDiv.className = 'slot-location-color';
          colorDiv.style.backgroundColor = slot.color;
          
          const nameDiv = document.createElement('div');
          nameDiv.textContent = slot.locationName;
          
          locationDiv.appendChild(colorDiv);
          locationDiv.appendChild(nameDiv);
          
          timeSlot.appendChild(timeDiv);
          timeSlot.appendChild(locationDiv);
          
          timeSlotsContainer.appendChild(timeSlot);
        });
      }
      
      timeSlotsContainer.style.display = 'block';
      scrollToBottom();
    }
    
    function selectInjectorTimeSlot(slot, timeStr, dateStr) {
      selectedTime = { id: slot.id, time: timeStr, date: dateStr, startTime: slot.startTime };
      selectedLocation = slot.locationName;
      selectedLocationId = LOCATIONS_DATA[slot.locationName].locationId;
      
      addMessage('user', `${dateStr} at ${timeStr} - ${slot.locationName}`);
      addMessage('system', `Perfect! I've noted your appointment with ${selectedInjector} at ${slot.locationName} on ${dateStr} at ${timeStr}. Let me prepare your booking...`);
      
      // Now we need to create a proper cart for this location and complete the booking
      createCartForInjectorBooking();
    }
    
    function createCartForInjectorBooking() {
      console.log('🎯 Creating cart for injector booking at', selectedLocation);
      
      const formattedLocationId = selectedLocationId.indexOf('urn:blvd:Location:') === 0 ? 
        selectedLocationId : 'urn:blvd:Location:' + selectedLocationId;
      
      const query = `
        mutation CreateCart($locationId: ID!) {
          createCart(input: { locationId: $locationId }) {
            cart {
              id
              availableCategories {
                availableItems {
                  id
                  name
                  ... on CartAvailableBookableItem {
                    staffVariants {
                      id
                      staff {
                        id
                        firstName
                        lastName
                      }
                    }
                  }
                }
              }
            }
          }
        }
      `;
      
      makeBoulevardRequest(query, { locationId: formattedLocationId })
        .then(data => {
          const cart = data.createCart.cart;
          cartId = cart.id;
          
          // Find a service this injector can perform
          let foundService = false;
          for (const category of cart.availableCategories) {
            for (const item of category.availableItems) {
              if (item.staffVariants) {
                const staffVariant = item.staffVariants.find(variant => 
                  variant.staff && variant.staff.id === selectedInjectorId
                );
                if (staffVariant) {
                  // Use the first available service
                  selectedService = item.name;
                  selectedServiceId = item.id;
                  
                  // Add service to cart and continue
                  return addInjectorServiceToCart(staffVariant.id);
                }
              }
            }
          }
          
          if (!foundService) {
            throw new Error('No services found for this injector at this location');
          }
        })
        .catch(error => {
          console.error('Failed to create cart for injector booking:', error);
          showErrorMessage('Unable to prepare booking. Please try again or contact us.');
        });
    }
    
    function addInjectorServiceToCart(staffVariantId) {
      const mutation = `
        mutation AddCartItem($cartId: ID!, $itemId: ID!, $itemStaffVariantId: ID!) {
          addCartSelectedBookableItem(input: {
            id: $cartId,
            itemId: $itemId,
            itemStaffVariantId: $itemStaffVariantId
          }) {
            cart {
              id
            }
          }
        }
      `;
      
      return makeBoulevardRequest(mutation, {
        cartId: cartId,
        itemId: selectedServiceId,
        itemStaffVariantId: staffVariantId
      })
        .then(() => {
          console.log('Service added to cart for injector booking');
          reserveInjectorTimeSlot();
        })
        .catch(error => {
          console.error('Failed to add service for injector booking:', error);
          showErrorMessage('Unable to add service. Please try again or contact us.');
        });
    }
    
    function reserveInjectorTimeSlot() {
      console.log('🔒 Reserving injector time slot:', selectedTime.id);
      
      const mutation = `
        mutation ReserveCartBookableItems($cartId: ID!, $bookableTimeId: ID!) {
          reserveCartBookableItems(input: {
            id: $cartId,
            bookableTimeId: $bookableTimeId
          }) {
            cart {
              id
            }
          }
        }
      `;
      
      makeBoulevardRequest(mutation, {
        cartId: cartId,
        bookableTimeId: selectedTime.id
      })
        .then(data => {
          console.log('✅ Injector time slot reserved successfully');
          addMessage('system', `Excellent! I've reserved your time slot with ${selectedInjector}. Now I need your contact information to complete your booking...`);
          showClientInfoForm();
        })
        .catch(error => {
          console.error('❌ Failed to reserve injector time slot:', error);
          addMessage('system', `I'm sorry, that time slot is no longer available. Please choose a different time.`);
          showErrorMessage('Time slot is no longer available. Please select a different time.');
        });
    }
    
function selectInjector(injectorId, injectorName) {
  selectedInjector = injectorName;
  selectedInjectorId = injectorId;
  addMessage('user', injectorName);
  
  // Check if this is "first available"
  if (injectorId === 'first-available') {
    addMessage('system', 'Perfect! Now please select your preferred location:', function() {
      showLocationSelection();
    });
    return;
  }
  
  // Find the selected staff member and check their locations
  const selectedStaff = availableStaff.find(s => s.id === selectedInjectorId);
  if (selectedStaff && selectedStaff.locations) {
    if (selectedStaff.locations.length === 1) {
      // Only works at one location - skip location selection
      selectedLocation = selectedStaff.locations[0];
      selectedLocationId = LOCATIONS_DATA[selectedLocation].locationId;
      addMessage('system', `Perfect! ${selectedInjector} works at our ${selectedLocation} location. Creating your booking session...`);
      createCart();
    } else {
      // Works at multiple locations - show selection but prepare for calendar toggle
      addMessage('system', `Great! ${selectedInjector} works at multiple locations. Please select your preferred location:`, function() {
        showLocationSelection();
      });
    }
  } else {
    // Fallback - show location selection
    addMessage('system', 'Perfect! Now please select your preferred location:', function() {
      showLocationSelection();
    });
  }
}
    function showStaffSelectionForLocation() {
  addMessage('system', `Great! Would you like to choose a specific injector at ${selectedLocation}?`, function() {
    const container = document.getElementById('messages');
    const staffMessage = document.createElement('div');
    staffMessage.className = 'message system';
    
    const bubble = document.createElement('div');
    bubble.className = 'message-bubble';
    
    const injectorContainer = document.createElement('div');
    injectorContainer.className = 'injector-container';
    
    const injectorList = document.createElement('div');
    injectorList.className = 'injector-list';
    
    // First Available option
    const firstAvailableItem = document.createElement('div');
    firstAvailableItem.className = 'injector-item first-available';
    firstAvailableItem.onclick = () => {
      selectedInjector = 'First Available';
      selectedInjectorId = 'first-available';
      addMessage('user', 'First Available');
      addMessage('system', 'Perfect! Let me show you our available services...', function() {
        showServices();
      });
    };
    
    const firstAvailablePhoto = document.createElement('div');
    firstAvailablePhoto.className = 'injector-photo';
    
    const firstAvailableName = document.createElement('div');
    firstAvailableName.className = 'injector-name';
    firstAvailableName.textContent = 'First Available';
    
    firstAvailableItem.appendChild(firstAvailablePhoto);
    firstAvailableItem.appendChild(firstAvailableName);
    injectorList.appendChild(firstAvailableItem);
    
    // Show injectors available at this location
    availableStaff.forEach(staff => {
      if (!staff.locations || staff.locations.includes(selectedLocation)) {
        const item = document.createElement('div');
        item.className = 'injector-item';
        item.onclick = () => {
          selectedInjector = `${staff.firstName} ${staff.lastName}`;
          selectedInjectorId = staff.id;
          addMessage('user', selectedInjector);
          addMessage('system', `Perfect! Let me show you ${selectedInjector}'s available services...`, function() {
            showServices();
          });
        };
        
        const photo = document.createElement('div');
        photo.className = 'injector-photo';
        if (staff.avatar && staff.avatar.url) {
          photo.style.backgroundImage = `url(${staff.avatar.url})`;
        }
        
        const name = document.createElement('div');
        name.className = 'injector-name';
        name.textContent = `${staff.firstName} ${staff.lastName}`;
        
        item.appendChild(photo);
        item.appendChild(name);
        injectorList.appendChild(item);
      }
    });
    
    injectorContainer.appendChild(injectorList);
    bubble.appendChild(injectorContainer);
    
    staffMessage.appendChild(bubble);
    container.appendChild(staffMessage);
    scrollToBottom();
  });
}
    function showLocationSelection() {
      const container = document.getElementById('messages');
      const locationMessage = document.createElement('div');
      locationMessage.className = 'message system';
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      
      const grid = document.createElement('div');
      grid.className = 'location-grid';
      
      let availableLocations = Object.keys(LOCATIONS_DATA);
      
      // If a specific injector is selected, only show their locations
      if (selectedInjectorId && selectedInjectorId !== 'first-available') {
        const selectedStaff = availableStaff.find(s => s.id === selectedInjectorId);
        if (selectedStaff && selectedStaff.locations) {
          availableLocations = selectedStaff.locations;
          console.log(`🎯 Filtering locations for ${selectedStaff.firstName} ${selectedStaff.lastName}:`, availableLocations);
        }
      }
      
      console.log('🏢 Showing locations:', availableLocations);
      
      availableLocations.forEach(locationName => {
        const button = document.createElement('button');
        button.className = 'location-button';
        button.textContent = locationName;
        button.onclick = () => selectLocation(locationName);
        grid.appendChild(button);
      });
      
      bubble.appendChild(grid);
      locationMessage.appendChild(bubble);
      container.appendChild(locationMessage);
      scrollToBottom();
    }
    
 function selectLocation(location) {
  selectedLocation = location;
  selectedLocationId = LOCATIONS_DATA[location].locationId;
  addMessage('user', location);
  
  addMessage('system', `Perfect! Creating your booking session for ${location}...`);
  createCart();
}
    function createCartWithLocationToggle() {
  // If injector works at multiple locations, show calendar with location toggle
  const selectedStaff = availableStaff.find(s => s.id === selectedInjectorId);
  if (selectedStaff && selectedStaff.locations && selectedStaff.locations.length > 1) {
    // Set up for multi-location view
    injectorLocations = selectedStaff.locations;
    assignLocationColors([selectedStaff]);
    visibleLocations = new Set(selectedStaff.locations);
    
    addMessage('system', `Great! Let me show you ${selectedInjector}'s availability across all their locations...`, function() {
      loadMultiLocationAvailability();
    });
  } else {
    // Single location - proceed normally
    createCart();
  }
}

function loadMultiLocationAvailability() {
  console.log('🔍 Loading availability for injector across multiple locations');
  
  const promises = injectorLocations.map(locationName => {
    return loadInjectorAvailabilityForLocation(locationName);
  });
  
  Promise.all(promises)
    .then(() => {
      console.log('✅ Loaded availability for all locations');
      showMultiLocationCalendar();
    })
    .catch(error => {
      console.error('❌ Failed to load availability:', error);
      showErrorMessage('Unable to load availability. Please try again or contact us.');
    });
}

function showMultiLocationCalendar() {
  const container = document.getElementById('messages');
  const calendarMessage = document.createElement('div');
  calendarMessage.className = 'message system';
  
  const bubble = document.createElement('div');
  bubble.className = 'message-bubble';
  
  // Location legend and toggle
  const legend = document.createElement('div');
  legend.className = 'location-legend';
  
  const legendTitle = document.createElement('div');
  legendTitle.className = 'legend-title';
  legendTitle.textContent = 'Locations (click to toggle):';
  
  const legendItems = document.createElement('div');
  legendItems.className = 'legend-items';
  
  injectorLocations.forEach(locationName => {
    const legendItem = document.createElement('div');
    legendItem.className = 'legend-item';
    if (!visibleLocations.has(locationName)) {
      legendItem.classList.add('inactive');
    }
    
    legendItem.onclick = () => toggleLocationVisibility(locationName);
    
    const colorDiv = document.createElement('div');
    colorDiv.className = 'legend-color';
    colorDiv.style.backgroundColor = locationColors[locationName];
    
    const nameDiv = document.createElement('div');
    nameDiv.textContent = locationName;
    
    legendItem.appendChild(colorDiv);
    legendItem.appendChild(nameDiv);
    legendItems.appendChild(legendItem);
  });
  
  legend.appendChild(legendTitle);
  legend.appendChild(legendItems);
  
  // Calendar container
  const availabilityContainer = document.createElement('div');
  availabilityContainer.className = 'availability-container';
  availabilityContainer.id = 'multi-location-availability-container';
  
  bubble.appendChild(legend);
  bubble.appendChild(availabilityContainer);
  
  calendarMessage.appendChild(bubble);
  container.appendChild(calendarMessage);
  scrollToBottom();
  
  renderMultiLocationCalendar();
}

function renderMultiLocationCalendar() {
  const container = document.getElementById('multi-location-availability-container');
  container.innerHTML = '';
  
  // Calendar header
  const calendarHeader = document.createElement('div');
  calendarHeader.className = 'calendar-header';
  
  const prevButton = document.createElement('button');
  prevButton.className = 'calendar-nav';
  prevButton.textContent = '← Previous';
  prevButton.onclick = () => navigateMultiLocationMonth(-1);
  
  const calendarTitle = document.createElement('div');
  calendarTitle.className = 'calendar-title';
  const displayDate = currentCalendarDate || new Date();
  calendarTitle.textContent = `${selectedInjector}'s Availability - ${displayDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}`;
  
  const nextButton = document.createElement('button');
  nextButton.className = 'calendar-nav';
  nextButton.textContent = 'Next →';
  nextButton.onclick = () => navigateMultiLocationMonth(1);
  
  calendarHeader.appendChild(prevButton);
  calendarHeader.appendChild(calendarTitle);
  calendarHeader.appendChild(nextButton);
  
  // Calendar grid
  const calendarGrid = document.createElement('div');
  calendarGrid.className = 'calendar-grid';
  
  // Day headers
  const dayHeaders = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  dayHeaders.forEach(day => {
    const dayHeader = document.createElement('div');
    dayHeader.className = 'calendar-day-header';
    dayHeader.textContent = day;
    calendarGrid.appendChild(dayHeader);
  });
  
  // Generate calendar for current month
  const today = new Date();
  const year = currentCalendarDate.getFullYear();
  const month = currentCalendarDate.getMonth();
  const firstDay = new Date(year, month, 1);
  const lastDay = new Date(year, month + 1, 0);
  
  // Add empty cells for days before the first day of the month
  for (let i = 0; i < firstDay.getDay(); i++) {
    const emptyDay = document.createElement('div');
    emptyDay.className = 'calendar-day disabled';
    calendarGrid.appendChild(emptyDay);
  }
  
  // Add days of the month
  for (let day = 1; day <= lastDay.getDate(); day++) {
    const date = new Date(year, month, day);
    const dateStr = date.toISOString().split('T')[0];
    const dayElement = document.createElement('div');
    dayElement.className = 'calendar-day injector-calendar-day';
    
    // Check if day is in the past
    if (date < today) {
      dayElement.classList.add('disabled');
    } else {
      dayElement.onclick = () => selectMultiLocationDate(date);
    }
    
    const dayNumber = document.createElement('div');
    dayNumber.className = 'day-number';
    dayNumber.textContent = day;
    
    const slotsContainer = document.createElement('div');
    slotsContainer.className = 'calendar-slots';
    
    // Add slot indicators for visible locations
    const dayData = injectorAvailabilityData[dateStr];
    if (dayData) {
      let hasSlots = false;
      
      Object.keys(dayData).forEach(locationName => {
        if (!visibleLocations.has(locationName)) return;
        
        const slots = dayData[locationName];
        if (slots && slots.length > 0) {
          hasSlots = true;
          
          // Show up to 3 slot indicators per location
          const slotsToShow = Math.min(3, slots.length);
          for (let i = 0; i < slotsToShow; i++) {
            const slotIndicator = document.createElement('div');
            slotIndicator.className = 'slot-indicator';
            slotIndicator.style.backgroundColor = locationColors[locationName];
            slotIndicator.title = `${locationName} - ${slots.length} slot${slots.length > 1 ? 's' : ''}`;
            slotsContainer.appendChild(slotIndicator);
          }
        }
      });
      
      if (hasSlots) {
        dayElement.classList.add('has-availability');
      }
    }
    
    dayElement.appendChild(dayNumber);
    dayElement.appendChild(slotsContainer);
    calendarGrid.appendChild(dayElement);
  }
  
  container.appendChild(calendarHeader);
  container.appendChild(calendarGrid);
  
  // Time slots container (initially hidden)
  const timeSlotsContainer = document.createElement('div');
  timeSlotsContainer.className = 'injector-time-slots';
  timeSlotsContainer.id = 'multi-location-time-slots-container';
  timeSlotsContainer.style.display = 'none';
  container.appendChild(timeSlotsContainer);
}
    
// Add missing function for multi-location date selection
function selectMultiLocationDate(date) {
  selectedDate = date;
  const dateStr = date.toISOString().split('T')[0];
  
  // Update selected state in calendar
  document.querySelectorAll('.injector-calendar-day').forEach(day => {
    day.classList.remove('selected');
  });
  
  // Find and select the clicked day
  const dayElements = document.querySelectorAll('.injector-calendar-day');
  dayElements.forEach(dayElement => {
    const dayNumber = dayElement.querySelector('.day-number');
    if (dayNumber && parseInt(dayNumber.textContent) === date.getDate()) {
      dayElement.classList.add('selected');
    }
  });
  
  showMultiLocationTimeSlotsForDate(date);
}

// Add missing function for showing time slots
function showMultiLocationTimeSlotsForDate(date) {
  const dateStr = date.toISOString().split('T')[0];
  const dayData = injectorAvailabilityData[dateStr];
  
  const timeSlotsContainer = document.getElementById('multi-location-time-slots-container');
  timeSlotsContainer.innerHTML = '';
  
  if (!dayData) {
    timeSlotsContainer.innerHTML = '<p style="text-align: center; color: #86868b; padding: 20px;">No availability data for this date</p>';
    timeSlotsContainer.style.display = 'block';
    return;
  }
  
  const allSlots = [];
  
  // Collect all slots from visible locations
  Object.keys(dayData).forEach(locationName => {
    if (!visibleLocations.has(locationName)) return;
    
    const slots = dayData[locationName] || [];
    slots.forEach(slot => {
      allSlots.push({
        ...slot,
        locationName: locationName,
        color: locationColors[locationName]
      });
    });
  });
  
  if (allSlots.length === 0) {
    timeSlotsContainer.innerHTML = '<p style="text-align: center; color: #86868b; padding: 20px;">No available times for this date</p>';
  } else {
    // Sort slots by time
    allSlots.sort((a, b) => new Date(a.startTime) - new Date(b.startTime));
    
    allSlots.forEach(slot => {
      const startTime = new Date(slot.startTime);
      const timeStr = startTime.toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      
      const timeSlot = document.createElement('div');
      timeSlot.className = 'injector-time-slot';
      timeSlot.onclick = () => selectMultiLocationTimeSlot(slot, timeStr, date.toLocaleDateString('en-US', {
        weekday: 'short',
        month: 'short',
        day: 'numeric'
      }));
      
      const timeDiv = document.createElement('div');
      timeDiv.className = 'slot-time';
      timeDiv.textContent = timeStr;
      
      const locationDiv = document.createElement('div');
      locationDiv.className = 'slot-location';
      
      const colorDiv = document.createElement('div');
      colorDiv.className = 'slot-location-color';
      colorDiv.style.backgroundColor = slot.color;
      
      const nameDiv = document.createElement('div');
      nameDiv.textContent = slot.locationName;
      
      locationDiv.appendChild(colorDiv);
      locationDiv.appendChild(nameDiv);
      
      timeSlot.appendChild(timeDiv);
      timeSlot.appendChild(locationDiv);
      
      timeSlotsContainer.appendChild(timeSlot);
    });
  }
  
  timeSlotsContainer.style.display = 'block';
  scrollToBottom();
}

// Add missing function for time slot selection
function selectMultiLocationTimeSlot(slot, timeStr, dateStr) {
  selectedTime = { id: slot.id, time: timeStr, date: dateStr, startTime: slot.startTime };
  selectedLocation = slot.locationName;
  selectedLocationId = LOCATIONS_DATA[slot.locationName].locationId;
  
  addMessage('user', `${dateStr} at ${timeStr} - ${slot.locationName}`);
  addMessage('system', `Perfect! I've noted your appointment with ${selectedInjector} at ${slot.locationName} on ${dateStr} at ${timeStr}. Let me prepare your booking...`);
  
  // Now we need to create a proper cart for this location and complete the booking
  createCartForInjectorBooking();
}

function navigateMultiLocationMonth(direction) {
  if (!currentCalendarDate) {
    currentCalendarDate = new Date();
  }
  currentCalendarDate.setMonth(currentCalendarDate.getMonth() + direction);
  
  // Clear existing availability data
  injectorAvailabilityData = {};
  
  // Reload availability
  loadMultiLocationAvailability();
}
    function createCart() {
  // Validate required state
  if (!selectedLocationId) {
    console.error('❌ No location selected for cart creation');
    showErrorMessage('Please select a location first.', false);
    return;
  }
  
  const formattedLocationId = selectedLocationId.indexOf('urn:blvd:Location:') === 0 ? 
    selectedLocationId : 'urn:blvd:Location:' + selectedLocationId;
  
  console.log('🛒 Creating cart for location:', selectedLocation, formattedLocationId);
  
  const query = `
    mutation CreateCart($locationId: ID!) {
      createCart(input: { locationId: $locationId }) {
        cart {
          id
          expiresAt
          availableCategories {
            name
            availableItems {
              id
              name
              description
              ... on CartAvailableBookableItem {
                listPrice
                listDuration
                staffVariants {
                  id
                  price
                  duration
                  staff {
                    id
                    firstName
                    lastName
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
  
  makeBoulevardRequest(query, { locationId: formattedLocationId })
    .then(data => {
      if (!data || !data.createCart || !data.createCart.cart) {
        throw new Error('Invalid cart creation response');
      }
      
      const cart = data.createCart.cart;
      cartId = cart.id;
      console.log('✅ Cart created successfully:', cartId);
      console.log('✅ Cart expires at:', cart.expiresAt);
      console.log('✅ Available categories:', cart.availableCategories?.length || 0);
      
      loadServices(cart);
    })
    .catch(error => {
      console.error('❌ Cart creation failed:', error);
      
      let errorMessage = 'Unable to create booking session.';
      if (error.message.includes('Network')) {
        errorMessage = 'Network connection issue. Please check your internet and try again.';
      } else if (error.message.includes('permission') || error.message.includes('unauthorized')) {
        errorMessage = 'Unable to access booking system. Please refresh the page and try again.';
      } else if (error.message.includes('location')) {
        errorMessage = 'Selected location is not available. Please choose a different location.';
      }
      
      showErrorMessage(errorMessage, true);
      
      // Add fallback contact option
      setTimeout(() => {
        const container = document.getElementById('messages');
        const contactMessage = document.createElement('div');
        contactMessage.className = 'message system';
        
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble';
        
        const contactButton = document.createElement('button');
        contactButton.className = 'secondary-button';
        contactButton.textContent = 'Contact us directly at (646) 346-8809';
        contactButton.onclick = () => openSMS('cart-error');
        
        bubble.appendChild(contactButton);
        contactMessage.appendChild(bubble);
        container.appendChild(contactMessage);
        scrollToBottom();
      }, 1000);
    });
}
    
    function loadServices(cart) {
  const categories = cart.availableCategories || [];
  const services = [];
  
  console.log('🔍 Loading services for treatment type:', treatmentType);
  console.log('🔍 Available categories:', categories.map(c => c.name));
  
  for (const category of categories) {
    let categoryItems = category.availableItems || [];
    
    // Filter services based on treatment type
    if (treatmentType === 'injectable') {
      categoryItems = categoryItems.filter(item => {
        const itemName = item.name.toLowerCase();
        const categoryName = category.name.toLowerCase();
        return itemName.includes('botox') ||
               itemName.includes('filler') ||
               itemName.includes('inject') ||
               itemName.includes('dysport') ||
               itemName.includes('restylane') ||
               itemName.includes('juvederm') ||
               categoryName.includes('inject') ||
               categoryName.includes('neuro') ||
               categoryName.includes('filler');
      });
    } else if (treatmentType === 'skin') {
      categoryItems = categoryItems.filter(item => {
        const itemName = item.name.toLowerCase();
        const categoryName = category.name.toLowerCase();
        return itemName.includes('laser') ||
               itemName.includes('microneedling') ||
               itemName.includes('facial') ||
               itemName.includes('peel') ||
               itemName.includes('hydrafacial') ||
               itemName.includes('dermaplaning') ||
               categoryName.includes('skin') ||
               categoryName.includes('facial') ||
               categoryName.includes('laser');
      });
    }
    
    console.log(`🔍 Category "${category.name}" filtered items:`, categoryItems.length);
    
    for (const item of categoryItems) {
      // Get staff variants for this service
      let staffVariants = item.staffVariants || [];
      
      // If we have a specific injector selected, filter to only their variants
      if (selectedInjectorId && selectedInjectorId !== 'first-available') {
        console.log('🎯 Filtering staff variants for injector:', selectedInjectorId);
        staffVariants = staffVariants.filter(variant => 
          variant.staff && variant.staff.id === selectedInjectorId
        );
        console.log('🎯 Found staff variants for injector:', staffVariants.length);
      }
      
      // Only include services that either have no staff requirement or have the selected staff
      if (staffVariants.length > 0 || (!selectedInjectorId || selectedInjectorId === 'first-available')) {
        services.push({
          id: item.id,
          name: item.name,
          description: item.description,
          price: item.listPrice,
          duration: item.listDuration,
          category: category.name,
          staffVariants: staffVariants
        });
      }
    }
  }
  
  console.log('🔍 Final filtered services:', services.length);
  
  if (services.length > 0) {
    availableServices = services;
    
    // Show staff selection for location-based injectable bookings (only if no specific injector selected)
    if (bookingFlow === 'by-location' && 
        treatmentType === 'injectable' && 
        (!selectedInjectorId || selectedInjectorId === 'first-available')) {
      console.log('🎯 Showing staff selection for location-based booking');
      showStaffSelectionForLocation();
      return;
    }
    
    console.log('🎯 Proceeding directly to service selection');
    showServices();
  } else {
    console.log('❌ No services found, showing fallback');
    showServiceFallback();
  }
}
  
    function showServices() {
      const treatmentLabel = treatmentType === 'injectable' ? 'injectable treatments' : 'skin treatments';
      addMessage('system', `Here are the available ${treatmentLabel} at ${selectedLocation}:`, function() {
        const container = document.getElementById('messages');
        const serviceMessage = document.createElement('div');
        serviceMessage.className = 'message system';
        
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble';
        
        const grid = document.createElement('div');
        grid.className = 'service-grid';
        
        for (const service of availableServices.slice(0, 10)) {
          const button = document.createElement('button');
          button.className = 'service-button';
          button.onclick = () => selectService(service.id, service.name);
          
          const serviceInfo = document.createElement('div');
          serviceInfo.className = 'service-info';
          
          const nameDiv = document.createElement('div');
          nameDiv.className = 'service-name';
          nameDiv.textContent = service.name;
          
          const durationDiv = document.createElement('div');
          durationDiv.className = 'service-duration';
          durationDiv.textContent = service.duration ? `${service.duration} minutes` : '';
          
          serviceInfo.appendChild(nameDiv);
          serviceInfo.appendChild(durationDiv);
          
          const priceDiv = document.createElement('div');
          priceDiv.className = 'service-price';
          priceDiv.textContent = service.price ? `$${Math.round(service.price / 100)}` : 'Contact for pricing';
          
          button.appendChild(serviceInfo);
          button.appendChild(priceDiv);
          grid.appendChild(button);
        }
        
        bubble.appendChild(grid);
        
        const smsButton = document.createElement('button');
        smsButton.className = 'secondary-button';
        smsButton.textContent = "Don't see what you're looking for? Contact us";
        smsButton.onclick = () => openSMS('service-inquiry');
        bubble.appendChild(smsButton);
        
        serviceMessage.appendChild(bubble);
        container.appendChild(serviceMessage);
        scrollToBottom();
      });
    }
    
    function selectService(serviceId, serviceName) {
      selectedService = serviceName;
      selectedServiceId = serviceId;
      addMessage('user', serviceName);
      
      addMessage('system', `Great! I've added ${serviceName} to your booking. Now let me find available appointment times...`);
      addServiceToCart();
    }
    
    function addServiceToCart() {
      const mutation = `
        mutation AddCartItem($cartId: ID!, $itemId: ID!, $itemStaffVariantId: ID) {
          addCartSelectedBookableItem(input: {
            id: $cartId,
            itemId: $itemId,
            itemStaffVariantId: $itemStaffVariantId
          }) {
            cart {
              id
              selectedItems {
                id
              }
            }
          }
        }
      `;
      
      const variables = { 
        cartId: cartId, 
        itemId: selectedServiceId 
      };
      
      // Add staff variant if we have a specific injector selected
      if (selectedInjectorId && selectedInjectorId !== 'first-available') {
        console.log('🎯 Looking for staff variant for injector:', selectedInjectorId);
        
        // Find the staff variant for the selected injector from the selected service
        const selectedServiceData = availableServices.find(s => s.id === selectedServiceId);
        console.log('🎯 Selected service data:', selectedServiceData);
        
        if (selectedServiceData && selectedServiceData.staffVariants) {
          const staffVariant = selectedServiceData.staffVariants.find(v => 
            v.staff && v.staff.id === selectedInjectorId
          );
          
          if (staffVariant) {
            console.log('🎯 Found staff variant:', staffVariant);
            variables.itemStaffVariantId = staffVariant.id;
          } else {
            console.log('🎯 No staff variant found for injector, will use first available');
          }
        }
      }
      
      console.log('🎯 Adding service to cart with variables:', variables);
      
      makeBoulevardRequest(mutation, variables)
        .then(data => {
          console.log('Service added to cart');
   loadCalendarAvailability();
        })
        .catch(error => {
          console.error('Failed to add service:', error.message);
          showErrorFallback('Unable to add service. Please try again or contact us.');
        });
    }
    function showClientSelection() {
  const container = document.getElementById('messages');
  const clientMessage = document.createElement('div');
  clientMessage.className = 'message system';
  
  const bubble = document.createElement('div');
  bubble.className = 'message-bubble';
  
  const grid = document.createElement('div');
  grid.className = 'treatment-grid';
  grid.style.gridTemplateColumns = '1fr'; // Stack vertically for 3 options
  
  // Existing client button
  const existingClientButton = document.createElement('button');
  existingClientButton.className = 'treatment-button';
  existingClientButton.onclick = () => selectClientType('existing');
  
  const existingClientTitle = document.createElement('div');
  existingClientTitle.className = 'treatment-title';
  existingClientTitle.textContent = 'Existing Client';
  
  const existingClientDesc = document.createElement('div');
  existingClientDesc.className = 'treatment-desc';
  existingClientDesc.textContent = 'I\'ve been to Get Plump before';
  
  existingClientButton.appendChild(existingClientTitle);
  existingClientButton.appendChild(existingClientDesc);
  
  // New client button
  const newClientButton = document.createElement('button');
  newClientButton.className = 'treatment-button';
  newClientButton.onclick = () => selectClientType('new');
  
  const newClientTitle = document.createElement('div');
  newClientTitle.className = 'treatment-title';
  newClientTitle.textContent = 'New Client';
  
  const newClientDesc = document.createElement('div');
  newClientDesc.className = 'treatment-desc';
  newClientDesc.textContent = 'First time at Get Plump';
  
  newClientButton.appendChild(newClientTitle);
  newClientButton.appendChild(newClientDesc);
  
  // Member button (special styling)
  const memberButton = document.createElement('button');
  memberButton.className = 'treatment-button member-button';
  memberButton.onclick = () => selectClientType('member');
  
  const memberTitle = document.createElement('div');
  memberTitle.className = 'treatment-title';
  memberTitle.textContent = 'Member';
  
  const memberDesc = document.createElement('div');
  memberDesc.className = 'treatment-desc';
  memberDesc.textContent = 'I\'m a Get Plump member';
  
  memberButton.appendChild(memberTitle);
  memberButton.appendChild(memberDesc);
  
  grid.appendChild(existingClientButton);
  grid.appendChild(newClientButton);
  grid.appendChild(memberButton);
  
  bubble.appendChild(grid);
  clientMessage.appendChild(bubble);
  container.appendChild(clientMessage);
  scrollToBottom();
}

function selectClientType(clientType) {
  const clientTypeNames = {
    'existing': 'Existing Client',
    'new': 'New Client', 
    'member': 'Member'
  };
  
  addMessage('user', clientTypeNames[clientType]);
  
  // Store client type for later use
  clientInfo.clientType = clientType;
  
  let message = 'Perfect!';
  if (clientType === 'new') {
    message = 'Perfect! As a new client, you\'ll receive our new client special pricing.';
  } else if (clientType === 'member') {
    message = 'Welcome back! Applying your member benefits.';
  }
  
  // Continue based on treatment type
  if (treatmentType === 'injectable') {
    addMessage('system', message + ' For injectable treatments, would you like to book with a specific injector or choose a location first?', function() {
      showInjectableBookingFlow();
    });
  } else if (treatmentType === 'skin') {
    addMessage('system', message + ' Please select your preferred location:', function() {
      showLocationSelection();
    });
  }
}
    
    function loadCalendarAvailability() {
      addMessage('system', 'Here are the available appointment times:', function() {
        showCalendarView();
        loadAvailabilityForMonth();
      });
    }
    
    function showCalendarView() {
      const container = document.getElementById('messages');
      const calendarMessage = document.createElement('div');
      calendarMessage.className = 'message system';
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      
      const availabilityContainer = document.createElement('div');
      availabilityContainer.className = 'availability-container';
      availabilityContainer.id = 'availability-container';
      
      bubble.appendChild(availabilityContainer);
      
      const smsButton = document.createElement('button');
      smsButton.className = 'secondary-button';
      smsButton.textContent = "Don't see a good time? Contact us";
      smsButton.onclick = () => openSMS('time-inquiry');
      bubble.appendChild(smsButton);
      
      calendarMessage.appendChild(bubble);
      container.appendChild(calendarMessage);
      scrollToBottom();
    }
    
    function renderCalendar() {
  // Initialize calendar date if not set
  if (!currentCalendarDate) {
    currentCalendarDate = new Date();
    currentCalendarDate.setDate(1);
    currentCalendarDate.setHours(0, 0, 0, 0);
  }
  
  const container = document.getElementById('availability-container');
  container.innerHTML = '';
  
  // Calendar header with navigation
  const calendarHeader = document.createElement('div');
  calendarHeader.className = 'calendar-header';
  
  const prevButton = document.createElement('button');
  prevButton.className = 'calendar-nav';
  prevButton.textContent = '← Previous';
  
  // Disable previous button if we're at current month
  const today = new Date();
  const isCurrentMonth = currentCalendarDate.getFullYear() === today.getFullYear() && 
                         currentCalendarDate.getMonth() === today.getMonth();
  if (isCurrentMonth) {
    prevButton.disabled = true;
  }
  
  prevButton.onclick = () => navigateMonth(-1);
  
  const calendarTitle = document.createElement('div');
  calendarTitle.className = 'calendar-title';
  calendarTitle.textContent = currentCalendarDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
  
  const nextButton = document.createElement('button');
  nextButton.className = 'calendar-nav';
  nextButton.textContent = 'Next →';
  nextButton.onclick = () => navigateMonth(1);
  
  calendarHeader.appendChild(prevButton);
  calendarHeader.appendChild(calendarTitle);
  calendarHeader.appendChild(nextButton);
  
  // Calendar grid
  const calendarGrid = document.createElement('div');
  calendarGrid.className = 'calendar-grid';
  
  // Day headers
  const dayHeaders = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  dayHeaders.forEach(day => {
    const dayHeader = document.createElement('div');
    dayHeader.className = 'calendar-day-header';
    dayHeader.textContent = day;
    calendarGrid.appendChild(dayHeader);
  });
  
  // Generate calendar days using currentCalendarDate
  const year = currentCalendarDate.getFullYear();
  const month = currentCalendarDate.getMonth();
  const firstDay = new Date(year, month, 1);
  const lastDay = new Date(year, month + 1, 0);
  
  // Add empty cells for days before the first day of the month
  for (let i = 0; i < firstDay.getDay(); i++) {
    const emptyDay = document.createElement('div');
    emptyDay.className = 'calendar-day disabled';
    calendarGrid.appendChild(emptyDay);
  }
  
  // Add days of the month
  for (let day = 1; day <= lastDay.getDate(); day++) {
    const date = new Date(year, month, day);
    const dateStr = date.toISOString().split('T')[0];
    const dayElement = document.createElement('div');
    dayElement.className = 'calendar-day';
    
    // Check if day is in the past
    if (date < today) {
      dayElement.classList.add('disabled');
    } else {
      dayElement.onclick = () => selectCalendarDate(date);
      
      // Check if this day has availability
      if (calendarAvailability[dateStr] && calendarAvailability[dateStr].length > 0) {
        dayElement.classList.add('has-availability');
      }
    }
    
    const dayNumber = document.createElement('div');
    dayNumber.className = 'day-number';
    dayNumber.textContent = day;
    
    const dayAvailability = document.createElement('div');
    dayAvailability.className = 'day-availability';
    if (calendarAvailability[dateStr] && calendarAvailability[dateStr].length > 0) {
      dayAvailability.textContent = `${calendarAvailability[dateStr].length} slots`;
    }
    
    dayElement.appendChild(dayNumber);
    dayElement.appendChild(dayAvailability);
    calendarGrid.appendChild(dayElement);
  }
  
  container.appendChild(calendarHeader);
  container.appendChild(calendarGrid);
  
  // Time slots container (initially hidden)
  const timeSlotsContainer = document.createElement('div');
  timeSlotsContainer.className = 'time-slots';
  timeSlotsContainer.id = 'time-slots-container';
  timeSlotsContainer.style.display = 'none';
  container.appendChild(timeSlotsContainer);
}
    
  function navigateMonth(direction) {
  // Initialize calendar date if not set
  if (!currentCalendarDate) {
    currentCalendarDate = new Date();
    currentCalendarDate.setDate(1);
    currentCalendarDate.setHours(0, 0, 0, 0);
  }
  
  const newDate = new Date(currentCalendarDate);
  newDate.setMonth(newDate.getMonth() + direction);
  
  // Don't allow navigation to past months
  const today = new Date();
  if (newDate.getFullYear() < today.getFullYear() || 
      (newDate.getFullYear() === today.getFullYear() && newDate.getMonth() < today.getMonth())) {
    console.log('Cannot navigate to past months');
    return; // Don't navigate to past months
  }
  
  console.log('Navigating to:', newDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' }));
  currentCalendarDate = newDate;
  
  // Clear existing availability data for the new month
  calendarAvailability = {};
  
  renderCalendar();
  loadAvailabilityForMonth();
}
    function loadAvailabilityForMonth() {
      const year = currentCalendarDate.getFullYear();
      const month = currentCalendarDate.getMonth();
      const firstDay = new Date(year, month, 1);
      const lastDay = new Date(year, month + 1, 0);
      
      // Load availability for all days in the month
      const promises = [];
      for (let day = 1; day <= lastDay.getDate(); day++) {
        const date = new Date(year, month, day);
        if (date >= new Date()) { // Only load for future dates
          promises.push(loadAvailabilityForDate(date));
        }
      }
      
      Promise.all(promises).then(() => {
        renderCalendar();
      });
    }
    
    function loadAvailabilityForDate(date) {
      const dateStr = date.toISOString().split('T')[0];
      
      const query = `
        query GetCartBookableTimes($cartId: ID!, $searchDate: Date!) {
          cartBookableTimes(
            id: $cartId,
            searchDate: $searchDate,
            tz: "America/New_York"
          ) {
            id
            startTime
          }
        }
      `;
      
      return makeBoulevardRequest(query, { 
        cartId: cartId, 
        searchDate: dateStr 
      })
        .then(data => {
          const times = data.cartBookableTimes || [];
          calendarAvailability[dateStr] = times;
          return times;
        })
        .catch(error => {
          console.error('Failed to load availability for', dateStr, error);
          calendarAvailability[dateStr] = [];
          return [];
        });
    }
    
    function selectCalendarDate(date) {
      selectedDate = date;
      const dateStr = date.toISOString().split('T')[0];
      
      // Update selected state in calendar
      document.querySelectorAll('.calendar-day').forEach(day => {
        day.classList.remove('selected');
      });
      
      // Find and select the clicked day
      const dayElements = document.querySelectorAll('.calendar-day');
      dayElements.forEach(dayElement => {
        const dayNumber = dayElement.querySelector('.day-number');
        if (dayNumber && parseInt(dayNumber.textContent) === date.getDate()) {
          dayElement.classList.add('selected');
        }
      });
      
      // Show time slots for this date
      showTimeSlotsForDate(date);
    }
    
    function showTimeSlotsForDate(date) {
      const dateStr = date.toISOString().split('T')[0];
      const times = calendarAvailability[dateStr] || [];
      
      const timeSlotsContainer = document.getElementById('time-slots-container');
      timeSlotsContainer.innerHTML = '';
      
      if (times.length === 0) {
        timeSlotsContainer.innerHTML = '<p style="text-align: center; color: #86868b; padding: 20px;">No available times for this date</p>';
      } else {
        times.forEach(time => {
          const startTime = new Date(time.startTime);
          const timeStr = startTime.toLocaleTimeString('en-US', {
            hour: 'numeric',
            minute: '2-digit',
            hour12: true
          });
          
          const timeSlot = document.createElement('div');
          timeSlot.className = 'time-slot';
          timeSlot.textContent = timeStr;
          timeSlot.onclick = () => selectTime(time.id, timeStr, date.toLocaleDateString('en-US', {
            weekday: 'short',
            month: 'short',
            day: 'numeric'
          }), time.startTime);
          
          timeSlotsContainer.appendChild(timeSlot);
        });
      }
      
      timeSlotsContainer.style.display = 'block';
      scrollToBottom();
    }
    
    function selectTime(timeId, timeStr, dateStr, startTime) {
      selectedTime = { id: timeId, time: timeStr, date: dateStr, startTime: startTime };
      addMessage('user', `${dateStr} at ${timeStr}`);
      
      addMessage('system', `Perfect! I've noted your preferred time: ${dateStr} at ${timeStr}. Let me reserve this time slot...`);
      
      // Reserve the time slot before showing the form
      reserveTimeSlot();
    }
    
    function reserveTimeSlot() {
      console.log('🔒 Reserving time slot:', selectedTime.id);
      
      const mutation = `
        mutation ReserveCartBookableItems($cartId: ID!, $bookableTimeId: ID!) {
          reserveCartBookableItems(input: {
            id: $cartId,
            bookableTimeId: $bookableTimeId
          }) {
            cart {
              id
            }
          }
        }
      `;
      
      makeBoulevardRequest(mutation, {
        cartId: cartId,
        bookableTimeId: selectedTime.id
      })
        .then(data => {
          console.log('✅ Time slot reserved successfully');
          addMessage('system', `Great! I've reserved your time slot. Now I need your contact information to complete your booking...`);
          showClientInfoForm();
        })
        .catch(error => {
          console.error('❌ Failed to reserve time slot:', error);
          addMessage('system', `I'm sorry, that time slot is no longer available. Please choose a different time.`);
          // Could reload times here or show error
          showErrorMessage('Time slot is no longer available. Please select a different time.');
        });
    }
    
    function showClientInfoForm() {
      setTimeout(function() {
        const container = document.getElementById('messages');
        const formMessage = document.createElement('div');
        formMessage.className = 'message system';
        
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble';
        
        const formContainer = document.createElement('div');
        formContainer.className = 'form-container';
        
        const contactTitle = document.createElement('div');
        contactTitle.className = 'form-section-title';
        contactTitle.textContent = 'Contact Information';
        
        const nameRow = document.createElement('div');
        nameRow.className = 'form-row';
        
        const firstNameInput = document.createElement('input');
        firstNameInput.type = 'text';
        firstNameInput.className = 'form-input';
        firstNameInput.id = 'firstName';
        firstNameInput.placeholder = 'First Name';
        
        const lastNameInput = document.createElement('input');
        lastNameInput.type = 'text';
        lastNameInput.className = 'form-input';
        lastNameInput.id = 'lastName';
        lastNameInput.placeholder = 'Last Name';
        
        nameRow.appendChild(firstNameInput);
        nameRow.appendChild(lastNameInput);
        
        const emailInput = document.createElement('input');
        emailInput.type = 'email';
        emailInput.className = 'form-input';
        emailInput.id = 'email';
        emailInput.placeholder = 'Email Address';
        
        const phoneInput = document.createElement('input');
        phoneInput.type = 'tel';
        phoneInput.className = 'form-input';
        phoneInput.id = 'phone';
        phoneInput.placeholder = 'Phone Number';
        
        const submitButton = document.createElement('button');
        submitButton.className = 'primary-button';
        submitButton.textContent = 'Complete Booking';
        submitButton.onclick = completeBooking;
        
        formContainer.appendChild(contactTitle);
        formContainer.appendChild(nameRow);
        formContainer.appendChild(emailInput);
        formContainer.appendChild(phoneInput);
        formContainer.appendChild(submitButton);
        
        bubble.appendChild(formContainer);
        formMessage.appendChild(bubble);
        container.appendChild(formMessage);
        scrollToBottom();
        
        setTimeout(() => firstNameInput.focus(), 100);
      }, 1000);
    }
    
    // FIXED: Complete booking function with proper Boulevard API calls
    function completeBooking() {
      const firstName = document.getElementById('firstName').value.trim();
      const lastName = document.getElementById('lastName').value.trim();
      const email = document.getElementById('email').value.trim();
      const phone = document.getElementById('phone').value.trim();
      
      // Clear previous errors
      document.querySelectorAll('.form-input').forEach(input => input.classList.remove('error'));
      document.querySelectorAll('.error-text').forEach(error => error.remove());
      
      let hasErrors = false;
      
      // Validate contact info
      if (!firstName) {
        showFieldError('firstName', 'First name is required');
        hasErrors = true;
      }
      
      if (!lastName) {
        showFieldError('lastName', 'Last name is required');
        hasErrors = true;
      }
      
      if (!email) {
        showFieldError('email', 'Email is required');
        hasErrors = true;
      } else if (!validateEmail(email)) {
        showFieldError('email', 'Please enter a valid email address');
        hasErrors = true;
      }
      
      if (!phone) {
        showFieldError('phone', 'Phone number is required');
        hasErrors = true;
      } else if (!validatePhoneNumber(phone)) {
        showFieldError('phone', 'Please enter a valid phone number');
        hasErrors = true;
      }
      
      if (hasErrors) return;
      
      clientInfo = { firstName, lastName, email, phoneNumber: phone };
      
      const button = document.querySelector('.primary-button');
      const originalText = button.textContent;
      button.textContent = 'Processing...';
      button.disabled = true;
      
      addMessage('user', `${firstName} ${lastName} - ${email}`);
      
      // Debug the schema first (optional - remove in production)
      console.log('🔍 Starting booking completion process...');
      
      // Process the booking with Boulevard API
      debugBookingCompleteSchema()
        .then(() => {
          return debugCartStatus();
        })
        .then(cart => {
          if (cart && cart.errors && cart.errors.length > 0) {
            console.error('❌ Cart has errors:', cart.errors);
            throw new Error(`Cart errors: ${cart.errors.map(e => e.message).join(', ')}`);
          }
          return updateCartWithClientInfo();
        })
        .then(() => {
          console.log('✅ Client info updated, attempting booking completion...');
          return completeAPIBooking();
        })
        .then((result) => {
          console.log('✅ Booking successful:', result);
          
          // Show any warnings to the user if needed
          if (result.warnings && result.warnings.length > 0) {
            console.warn('⚠️ Booking completed with warnings:', result.warnings);
          }
          
          button.textContent = originalText;
          button.disabled = false;
          
          showBookingSuccess(result);
        })
        .catch(error => {
          button.textContent = originalText;
          button.disabled = false;
          console.error('❌ Booking completion failed:', error);
          
          // More specific error handling
          let errorMessage = 'Booking failed. Please contact us to complete your appointment.';
          
          if (error.message.includes('payment')) {
            errorMessage = 'Payment is required to complete this booking. Please contact us.';
          } else if (error.message.includes('permission') || error.message.includes('unauthorized')) {
            errorMessage = 'Unable to complete booking due to permissions. Please contact us.';
          } else if (error.message.includes('time') || error.message.includes('available')) {
            errorMessage = 'The selected time is no longer available. Please choose a different time.';
          } else if (error.message.includes('GraphQL Error')) {
            errorMessage = `Booking system error: ${error.message}. Please contact us.`;
          }
          
          showErrorMessage(errorMessage);
          
          // Also show a fallback contact option
          setTimeout(() => {
            showSMSOption();
          }, 2000);
        });
    }
    
    function updateCartWithClientInfo() {
      console.log('✅ Updating cart with client info...');
      
      const query = `
        mutation UpdateCart($cartId: ID!, $email: Email!, $firstName: String!, $lastName: String!, $phoneNumber: PhoneNumber!) {
          updateCart(input: {
            id: $cartId,
            clientInformation: {
              email: $email,
              firstName: $firstName,
              lastName: $lastName,
              phoneNumber: $phoneNumber
            }
          }) {
            cart {
              id
              clientInformation {
                firstName
                lastName
                email
                phoneNumber
              }
            }
          }
        }
      `;
      
      return makeBoulevardRequest(query, {
        cartId: cartId,
        email: clientInfo.email,
        firstName: clientInfo.firstName,
        lastName: clientInfo.lastName,
        phoneNumber: clientInfo.phoneNumber
      })
      .then(data => {
        console.log('✅ Cart updated with client info:', data);
        return data;
      })
      .catch(error => {
        console.error('❌ Update cart failed:', error);
        // Don't fail the whole process if this fails
        return Promise.resolve();
      });
    }
    
    function showFieldError(fieldId, message) {
      const field = document.getElementById(fieldId);
      field.classList.add('error');
      
      const errorDiv = document.createElement('div');
      errorDiv.className = 'error-text';
      errorDiv.textContent = message;
      
      field.parentNode.insertBefore(errorDiv, field.nextSibling);
    }
    
    function showErrorMessage(message) {
      const container = document.getElementById('messages');
      const errorMessage = document.createElement('div');
      errorMessage.className = 'message system';
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      bubble.innerHTML = `<div class="error-message">${message}</div>`;
      
      errorMessage.appendChild(bubble);
      container.appendChild(errorMessage);
      scrollToBottom();
    }
    
    function showBookingSuccess(result) {
      const injectorText = selectedInjector ? `Provider: ${selectedInjector}<br>` : '';
      const bookingIdText = result && result.bookingId ? `<br>Booking ID: ${result.bookingId}` : '';
      const appointmentIdText = result && result.appointmentId ? `<br>Appointment ID: ${result.appointmentId}` : '';
      
      const successMessage = `<div class="success-message"><strong>✅ Booking Completed Successfully!</strong><br><br>` +
                            `Location: ${selectedLocation}<br>` +
                            `Service: ${selectedService}<br>` +
                            `Date & Time: ${selectedTime.date} at ${selectedTime.time}<br>` +
                            `${injectorText}` +
                            `Client: ${clientInfo.firstName} ${clientInfo.lastName}<br>` +
                            `${bookingIdText}${appointmentIdText}<br><br>` +
                            `Your appointment has been confirmed and added to our calendar. You should receive a confirmation email shortly.</div>`;
      
      addMessage('system', successMessage, function() {
        showPostBookingOptions();
      });
    }
    
    function showPostBookingOptions() {
      const container = document.getElementById('messages');
      const optionsMessage = document.createElement('div');
      optionsMessage.className = 'message system';
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      
      const bookButton = document.createElement('button');
      bookButton.className = 'primary-button';
      bookButton.textContent = 'Book Another Appointment';
      bookButton.onclick = restartChat;
      
      const smsButton = document.createElement('button');
      smsButton.className = 'secondary-button';
      smsButton.textContent = 'Questions? Contact Us';
      smsButton.onclick = () => openSMS('follow-up');
      
      bubble.appendChild(bookButton);
      bubble.appendChild(smsButton);
      
      optionsMessage.appendChild(bubble);
      container.appendChild(optionsMessage);
      scrollToBottom();
    }
    
    function showServiceFallback() {
      addMessage('system', 'I\'m having trouble loading services right now. Let me connect you with our team:', function() {
        showSMSOption();
      });
    }
    
    function showNoAvailabilityMessage() {
      addMessage('system', `I don't see any available times in the next two weeks. Let me connect you with our team:`, function() {
        showSMSOption();
      });
    }
    
    function showErrorFallback(message) {
      addMessage('system', message + ' Let me connect you:', function() {
        showSMSOption();
      });
    }
    
    function showSMSOption() {
      const container = document.getElementById('messages');
      const smsMessage = document.createElement('div');
      smsMessage.className = 'message system';
      
      const bubble = document.createElement('div');
      bubble.className = 'message-bubble';
      
      const smsButton = document.createElement('button');
      smsButton.className = 'secondary-button';
      smsButton.textContent = 'Text us at (646) 346-8809';
      smsButton.onclick = () => openSMS('help');
      
      bubble.appendChild(smsButton);
      smsMessage.appendChild(bubble);
      
      container.appendChild(smsMessage);
      scrollToBottom();
    }
    
    function openSMS(context) {
      let message = "I'd like to book an appointment at Get Plump";
      
      if (context === 'follow-up') {
        message = "I just completed a booking and have a question";
      } else if (context === 'injector-inquiry') {
        message = 'I\'m looking for a specific injector that wasn\'t listed';
      } else if (context === 'service-inquiry') {
        message = `I'm looking for services at ${selectedLocation} but need different options`;
      } else if (context === 'time-inquiry') {
        message = `I'm looking for ${selectedService} at ${selectedLocation} but need different time options`;
      }
      
      message += ".";
      
      const encodedMessage = encodeURIComponent(message);
      window.location.href = 'sms:+16463468809?body=' + encodedMessage;
    }
    
    function restartChat() {
      startConversation();
    }
    
    function scrollToBottom() {
      const container = document.getElementById('messages');
      setTimeout(() => {
        container.scrollTop = container.scrollHeight;
      }, 100);
    }
    
    console.log('✅ Script fully loaded with proxy API integration');
    // ADD THESE MISSING FUNCTIONS TO YOUR SCRIPT

// Missing function for multi-location date selection
function selectMultiLocationDate(date) {
  selectedDate = date;
  const dateStr = date.toISOString().split('T')[0];
  
  // Update selected state in calendar
  document.querySelectorAll('.injector-calendar-day').forEach(day => {
    day.classList.remove('selected');
  });
  
  // Find and select the clicked day
  const dayElements = document.querySelectorAll('.injector-calendar-day');
  dayElements.forEach(dayElement => {
    const dayNumber = dayElement.querySelector('.day-number');
    if (dayNumber && parseInt(dayNumber.textContent) === date.getDate()) {
      dayElement.classList.add('selected');
    }
  });
  
  showMultiLocationTimeSlotsForDate(date);
}

// Missing function for showing multi-location time slots
function showMultiLocationTimeSlotsForDate(date) {
  const dateStr = date.toISOString().split('T')[0];
  const dayData = injectorAvailabilityData[dateStr];
  
  const timeSlotsContainer = document.getElementById('multi-location-time-slots-container');
  timeSlotsContainer.innerHTML = '';
  
  if (!dayData) {
    timeSlotsContainer.innerHTML = '<p style="text-align: center; color: #86868b; padding: 20px;">No availability data for this date</p>';
    timeSlotsContainer.style.display = 'block';
    return;
  }
  
  const allSlots = [];
  
  // Collect all slots from visible locations
  Object.keys(dayData).forEach(locationName => {
    if (!visibleLocations.has(locationName)) return;
    
    const slots = dayData[locationName] || [];
    slots.forEach(slot => {
      allSlots.push({
        ...slot,
        locationName: locationName,
        color: locationColors[locationName]
      });
    });
  });
  
  if (allSlots.length === 0) {
    timeSlotsContainer.innerHTML = '<p style="text-align: center; color: #86868b; padding: 20px;">No available times for this date</p>';
  } else {
    // Sort slots by time
    allSlots.sort((a, b) => new Date(a.startTime) - new Date(b.startTime));
    
    allSlots.forEach(slot => {
      const startTime = new Date(slot.startTime);
      const timeStr = startTime.toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
      });
      
      const timeSlot = document.createElement('div');
      timeSlot.className = 'injector-time-slot';
      timeSlot.onclick = () => selectMultiLocationTimeSlot(slot, timeStr, date.toLocaleDateString('en-US', {
        weekday: 'short',
        month: 'short',
        day: 'numeric'
      }));
      
      const timeDiv = document.createElement('div');
      timeDiv.className = 'slot-time';
      timeDiv.textContent = timeStr;
      
      const locationDiv = document.createElement('div');
      locationDiv.className = 'slot-location';
      
      const colorDiv = document.createElement('div');
      colorDiv.className = 'slot-location-color';
      colorDiv.style.backgroundColor = slot.color;
      
      const nameDiv = document.createElement('div');
      nameDiv.textContent = slot.locationName;
      
      locationDiv.appendChild(colorDiv);
      locationDiv.appendChild(nameDiv);
      
      timeSlot.appendChild(timeDiv);
      timeSlot.appendChild(locationDiv);
      
      timeSlotsContainer.appendChild(timeSlot);
    });
  }
  
  timeSlotsContainer.style.display = 'block';
  scrollToBottom();
}

// Missing function for multi-location time slot selection
function selectMultiLocationTimeSlot(slot, timeStr, dateStr) {
  selectedTime = { id: slot.id, time: timeStr, date: dateStr, startTime: slot.startTime };
  selectedLocation = slot.locationName;
  selectedLocationId = LOCATIONS_DATA[slot.locationName].locationId;
  
  addMessage('user', `${dateStr} at ${timeStr} - ${slot.locationName}`);
  addMessage('system', `Perfect! I've noted your appointment with ${selectedInjector} at ${slot.locationName} on ${dateStr} at ${timeStr}. Let me prepare your booking...`);
  
  // Now we need to create a proper cart for this location and complete the booking
  createCartForInjectorBooking();
}

// Enhanced error message function
function showErrorMessage(message, isRetryable = true) {
  const container = document.getElementById('messages');
  const errorMessage = document.createElement('div');
  errorMessage.className = 'message system';
  
  const bubble = document.createElement('div');
  bubble.className = 'message-bubble';
  
  const errorDiv = document.createElement('div');
  errorDiv.className = 'error-message';
  errorDiv.innerHTML = `<strong>⚠️ ${message}</strong>`;
  
  bubble.appendChild(errorDiv);
  
  // Add retry button for retryable errors
  if (isRetryable) {
    const retryButton = document.createElement('button');
    retryButton.className = 'secondary-button';
    retryButton.textContent = 'Try Again';
    retryButton.onclick = () => {
      errorMessage.remove();
      // Try to restart the current step
      if (selectedLocation && !cartId) {
        createCart();
      } else if (!selectedLocation) {
        showLocationSelection();
      } else {
        startConversation();
      }
    };
    bubble.appendChild(retryButton);
  }
  
  // Always add contact option
  const contactButton = document.createElement('button');
  contactButton.className = 'secondary-button';
  contactButton.textContent = 'Contact Support';
  contactButton.onclick = () => openSMS('error-help');
  bubble.appendChild(contactButton);
  
  errorMessage.appendChild(bubble);
  container.appendChild(errorMessage);
  scrollToBottom();
}

// Initialize calendar date helper
function initializeCalendarDate() {
  if (!currentCalendarDate) {
    currentCalendarDate = new Date();
    currentCalendarDate.setDate(1);
    currentCalendarDate.setHours(0, 0, 0, 0);
  }
}
  </script>
</body>
</html>
